<roblox version="4">
  <Item class="HttpService" referent="0">
    <Properties>
      <string name="Name">HttpService</string>
      <bool name="HttpEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="ReplicatedStorage" referent="1">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="2">
      <Properties>
        <string name="Name">TS</string>
      </Properties>
      <Item class="Folder" referent="3">
        <Properties>
          <string name="Name">components</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">module</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local function makeHello(name)
	return "Hello from " .. (name .. "!")
end
return {
	makeHello = makeHello,
}
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">network</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local createNetworkingEvent = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "networking", "out", "events", "createNetworkingEvent").createNetworkingEvent
local createNetworkingFunction = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "networking", "out", "functions", "createNetworkingFunction").createNetworkingFunction
local GlobalEvents = createNetworkingEvent("lobby/src/shared/network@GlobalEvents", {}, {}, nil, nil, nil)
local GlobalFunctions = createNetworkingFunction("lobby/src/shared/network@GlobalFunctions", {}, {}, nil, nil, nil)
return {
	GlobalEvents = GlobalEvents,
	GlobalFunctions = GlobalFunctions,
}
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="6">
      <Properties>
        <string name="Name">TS/common</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="7">
      <Properties>
        <string name="Name">assets</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="8">
      <Properties>
        <string name="Name">assets/shared</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="9">
      <Properties>
        <string name="Name">rbxts_include</string>
      </Properties>
      <Item class="ModuleScript" referent="10">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Return a Promise from the success or failure handler and it will be chained onto.

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::


	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.

	Returns a new promise chained from this promise.

	:::caution
	If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.

	:::caution
	`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href="/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence">this example</a>). You should use `andThen` instead if you only care about the Resolved case.
	:::

	:::warning
	Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.
	:::

	Returns a new promise chained from this promise.

	@param doneHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:done(doneHandler)
	assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, "Promise:done"))
	return self:_finally(debug.traceback(nil, 2), doneHandler, true)
end

--[=[
	Same as `andThenCall`, except for `done`.

	Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:doneCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[=[
	Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:doneReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:done(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="11">
        <Properties>
          <string name="Name">RuntimeLib</string>
          <string name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="12">
        <Properties>
          <string name="Name">node_modules</string>
        </Properties>
        <Item class="Folder" referent="13">
          <Properties>
            <string name="Name">@flamework</string>
          </Properties>
          <Item class="Folder" referent="14">
            <Properties>
              <string name="Name">components</string>
            </Properties>
            <Item class="ModuleScript" referent="15">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Maid = TS.import(script, TS.getModule(script, "@rbxts", "maid").Maid)
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local CollectionService = _services.CollectionService
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local ServerStorage = _services.ServerStorage
local _core = TS.import(script, TS.getModule(script, "@flamework", "core").out)
local Service = _core.Service
local Controller = _core.Controller
local Flamework = _core.Flamework
local Reflect = _core.Reflect
local Modding = _core.Modding
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "signal"))
local ComponentTracker = TS.import(script, script, "componentTracker").ComponentTracker
local DEFAULT_ANCESTOR_BLACKLIST = { ServerStorage, ReplicatedStorage }
--[[
	*
	* Register a class as a Component.
	*
	* @metadata flamework:implements flamework:parameters injectable
]]
local Component = Modding.createMetaDecorator("Class")
local BaseComponent
do
	BaseComponent = setmetatable({}, {
		__tostring = function()
			return "BaseComponent"
		end,
	})
	BaseComponent.__index = BaseComponent
	function BaseComponent.new(...)
		local self = setmetatable({}, BaseComponent)
		return self:constructor(...) or self
	end
	function BaseComponent:constructor()
		self.maid = Maid.new()
		self._attributeChangeHandlers = {}
	end
	function BaseComponent:setInstance(instance, attributes)
		self.instance = instance
		self.attributes = attributes
	end
	function BaseComponent:setAttribute(key, value, postfix)
		local previousValue = self.attributes[key]
		self.attributes[key] = value
		self.instance:SetAttribute(key, value)
		return if postfix then previousValue else value
	end
	function BaseComponent:onAttributeChanged(name, cb)
		local __attributeChangeHandlers = self._attributeChangeHandlers
		local _name = name
		local list = __attributeChangeHandlers[_name]
		if not list then
			local __attributeChangeHandlers_1 = self._attributeChangeHandlers
			local _exp = name
			list = Signal.new()
			local _list = list
			__attributeChangeHandlers_1[_exp] = _list
		end
		return list:Connect(cb)
	end
	function BaseComponent:destroy()
		self.maid:Destroy()
		for _, changeHandler in self._attributeChangeHandlers do
			changeHandler:Destroy()
		end
	end
end
--[[
	*
	* This class is responsible for loading and managing
	* all components in the game.
]]
local Components
do
	Components = setmetatable({}, {
		__tostring = function()
			return "Components"
		end,
	})
	Components.__index = Components
	function Components.new(...)
		local self = setmetatable({}, Components)
		return self:constructor(...) or self
	end
	function Components:constructor()
		self.components = {}
		self.classParentCache = {}
		self.activeComponents = {}
		self.activeInheritedComponents = {}
		self.reverseComponentsMapping = {}
		self.trackers = {}
		self.componentWaiters = {}
	end
	function Components:onInit()
		local components = {}
		local componentConstructors = Modding.getDecorators("$c:init@Component")
		for _, _binding in componentConstructors do
			local ctor = _binding.object
			local args = _binding.arguments
			local identifier = Reflect.getMetadata(ctor, "identifier")
			local componentDependencies = {}
			local parameters = Reflect.getMetadata(ctor, "flamework:parameters")
			if parameters then
				for _1, dependency in parameters do
					local object = Reflect.idToObj[dependency]
					if not object then
						continue
					end
					if not Modding.getDecorator(object, nil, "$c:init@Component") then
						continue
					end
					table.insert(componentDependencies, object)
				end
			end
			local _arg1 = {
				ctor = ctor,
				config = args[1] or {},
				componentDependencies = componentDependencies,
				identifier = identifier,
			}
			components[ctor] = _arg1
		end
		self.components = components
	end
	function Components:onStart()
		for _, _binding in self.components do
			local config = _binding.config
			local ctor = _binding.ctor
			local identifier = _binding.identifier
			local ancestorBlacklist = config.ancestorBlacklist or DEFAULT_ANCESTOR_BLACKLIST
			local ancestorWhitelist = config.ancestorWhitelist
			if config.tag ~= nil then
				local tracker = self:getComponentTracker(ctor)
				local predicate = self:getConfigValue(ctor, "predicate")
				local listener = function(isQualified, instance)
					if isQualified then
						self:addComponent(instance, ctor, true)
					else
						self:removeComponent(instance, ctor)
					end
				end
				local instanceAdded = function(instance)
					if predicate ~= nil and not predicate(instance) then
						return nil
					end
					local _isWhitelisted = ancestorWhitelist
					if _isWhitelisted ~= nil then
						local _arg0 = function(ancestor)
							return instance:IsDescendantOf(ancestor)
						end
						-- ▼ ReadonlyArray.some ▼
						local _result = false
						for _k, _v in _isWhitelisted do
							if _arg0(_v, _k - 1, _isWhitelisted) then
								_result = true
								break
							end
						end
						-- ▲ ReadonlyArray.some ▲
						_isWhitelisted = _result
					end
					local isWhitelisted = _isWhitelisted
					if isWhitelisted == false then
						return nil
					end
					local _arg0 = function(ancestor)
						return instance:IsDescendantOf(ancestor)
					end
					-- ▼ ReadonlyArray.some ▼
					local _result = false
					for _k, _v in ancestorBlacklist do
						if _arg0(_v, _k - 1, ancestorBlacklist) then
							_result = true
							break
						end
					end
					-- ▲ ReadonlyArray.some ▲
					local isBlacklisted = _result
					if isBlacklisted and isWhitelisted == nil then
						return nil
					end
					tracker:trackInstance(instance, listener)
					tracker:setHasTag(instance, true)
				end
				CollectionService:GetInstanceAddedSignal(config.tag):Connect(instanceAdded)
				CollectionService:GetInstanceRemovedSignal(config.tag):Connect(function(instance)
					tracker:untrackInstance(instance, listener)
					tracker:setHasTag(instance, false)
					self:removeComponent(instance, ctor)
				end)
				for _1, instance in CollectionService:GetTagged(config.tag) do
					self:safeCall("Failed to instantiate '" .. (identifier .. ("' for " .. instance:GetFullName())), function()
						return instanceAdded(instance)
					end, false)
				end
			end
		end
	end
	function Components:getComponentTracker(component)
		local _trackers = self.trackers
		local _component = component
		local existingTracker = _trackers[_component]
		if existingTracker then
			return existingTracker
		end
		local _components = self.components
		local _component_1 = component
		local componentInfo = _components[_component_1]
		assert(componentInfo, "Provided component does not exist")
		local instanceGuard = self:getConfigValue(component, "instanceGuard")
		local dependencies = {}
		for _, dependency in componentInfo.componentDependencies do
			local _arg0 = self:getComponentTracker(dependency)
			table.insert(dependencies, _arg0)
		end
		local tracker = ComponentTracker.new(componentInfo.identifier, {
			tag = componentInfo.config.tag,
			typeGuard = instanceGuard,
			typeGuardPoll = RunService:IsClient(),
			warningTimeout = componentInfo.config.warningTimeout,
			dependencies = dependencies,
		})
		local _trackers_1 = self.trackers
		local _component_2 = component
		_trackers_1[_component_2] = tracker
		return tracker
	end
	function Components:getParentConstructor(ctor)
		local metatable = getmetatable(ctor)
		if metatable and type(metatable) == "table" then
			local parentConstructor = rawget(metatable, "__index")
			return parentConstructor
		end
	end
	function Components:getOrderedParents(ctor, omitBaseComponent)
		if omitBaseComponent == nil then
			omitBaseComponent = true
		end
		local _classParentCache = self.classParentCache
		local _ctor = ctor
		local cache = _classParentCache[_ctor]
		if cache then
			return cache
		end
		local classes = { ctor }
		local nextParent = ctor
		while true do
			nextParent = self:getParentConstructor(nextParent)
			if not (nextParent ~= nil) then
				break
			end
			if not omitBaseComponent or nextParent ~= BaseComponent then
				local _nextParent = nextParent
				table.insert(classes, _nextParent)
			end
		end
		local _classParentCache_1 = self.classParentCache
		local _ctor_1 = ctor
		_classParentCache_1[_ctor_1] = classes
		return classes
	end
	function Components:getAttributeGuards(ctor)
		local attributes = {}
		local _components = self.components
		local _ctor = ctor
		local metadata = _components[_ctor]
		if metadata then
			if metadata.config.attributes ~= nil then
				for attribute, guard in pairs(metadata.config.attributes) do
					attributes[attribute] = guard
				end
			end
			local parentCtor = getmetatable(ctor)
			if parentCtor.__index ~= nil then
				for attribute, guard in self:getAttributeGuards(parentCtor.__index) do
					if not (attributes[attribute] ~= nil) then
						attributes[attribute] = guard
					end
				end
			end
		end
		return attributes
	end
	function Components:getAttributes(instance, componentInfo, guards)
		local attributes = instance:GetAttributes()
		local newAttributes = {}
		local defaults = self:getConfigValue(componentInfo.ctor, "defaults")
		for key, guard in pairs(guards) do
			local attribute = attributes[key]
			if not guard(attribute) then
				local _result = defaults
				if _result ~= nil then
					_result = _result[key]
				end
				if _result ~= nil then
					local _arg1 = defaults[key]
					newAttributes[key] = _arg1
					instance:SetAttribute(key, defaults[key])
				else
					error(instance:GetFullName() .. (" has invalid attribute '" .. (key .. ("' for '" .. (componentInfo.identifier .. "'")))))
				end
			else
				newAttributes[key] = attribute
			end
		end
		return newAttributes
	end
	function Components:getConfigValue(ctor, key)
		local _components = self.components
		local _ctor = ctor
		local metadata = _components[_ctor]
		if metadata then
			if metadata.config[key] ~= nil then
				return metadata.config[key]
			end
			local parentCtor = getmetatable(ctor)
			if parentCtor.__index ~= nil then
				return self:getConfigValue(parentCtor.__index, key)
			end
		end
	end
	function Components:safeCall(message, func, printStack)
		if printStack == nil then
			printStack = true
		end
		task.spawn(function()
			xpcall(func, function(err)
				local _err = err
				local _condition = type(_err) == "string"
				if _condition then
					_condition = printStack
				end
				if _condition then
					local stack = debug.traceback(err, 2)
					warn(message)
					warn(stack)
				else
					warn(message)
					warn(err)
					if printStack then
						warn(debug.traceback(nil, 2))
					end
				end
			end)
		end)
	end
	function Components:setupComponent(instance, attributes, component, construct, _param)
		local config = _param.config
		local ctor = _param.ctor
		local identifier = _param.identifier
		component:setInstance(instance, attributes)
		construct()
		if Flamework._implements(component, "$:flamework@OnStart") then
			local name = instance:GetFullName()
			self:safeCall("Component '" .. (identifier .. ("' failed to start " .. name)), function()
				return component:onStart()
			end)
		end
		Modding.addListener(component)
		component.maid:GiveTask(function()
			return Modding.removeListener(component)
		end)
		local refreshAttributes = self:getConfigValue(ctor, "refreshAttributes")
		if refreshAttributes == nil or refreshAttributes then
			local attributeCache = table.clone(attributes)
			local attributeGuards = self:getAttributeGuards(ctor)
			for attribute, guard in pairs(attributeGuards) do
				if type(attribute) == "string" then
					component.maid:GiveTask(instance:GetAttributeChangedSignal(attribute):Connect(function()
						local signal = component._attributeChangeHandlers[attribute]
						local value = instance:GetAttribute(attribute)
						local attributes = component.attributes
						if guard(value) then
							local _result = signal
							if _result ~= nil then
								_result:Fire(value, attributeCache[attribute])
							end
							attributes[attribute] = value
							attributeCache[attribute] = value
						end
					end))
				end
			end
		end
		local _componentWaiters = self.componentWaiters
		local _instance = instance
		local instanceWaiters = _componentWaiters[_instance]
		local _componentWaiters_1 = instanceWaiters
		if _componentWaiters_1 ~= nil then
			_componentWaiters_1 = _componentWaiters_1[ctor]
		end
		local componentWaiters = _componentWaiters_1
		if componentWaiters then
			instanceWaiters[ctor] = nil
			-- ▼ ReadonlyMap.size ▼
			local _size = 0
			for _ in instanceWaiters do
				_size += 1
			end
			-- ▲ ReadonlyMap.size ▲
			if _size == 0 then
				local _componentWaiters_2 = self.componentWaiters
				local _instance_1 = instance
				_componentWaiters_2[_instance_1] = nil
			end
			for waiter in componentWaiters do
				waiter(component)
			end
		end
	end
	function Components:getComponentFromSpecifier(componentSpecifier)
		local _componentSpecifier = componentSpecifier
		local _result
		if type(_componentSpecifier) == "string" then
			local _idToObj = Reflect.idToObj
			local _componentSpecifier_1 = componentSpecifier
			_result = (_idToObj[_componentSpecifier_1])
		else
			_result = componentSpecifier
		end
		return _result
	end
	function Components:getIdFromSpecifier(componentSpecifier)
		if componentSpecifier ~= nil then
			local _componentSpecifier = componentSpecifier
			return if type(_componentSpecifier) == "string" then componentSpecifier else Reflect.getMetadata(componentSpecifier, "identifier")
		end
	end
	function Components:addIdMapping(value, id, inheritedComponents)
		local _inheritedComponents = inheritedComponents
		local _id = id
		local instances = _inheritedComponents[_id]
		if not instances then
			local _inheritedComponents_1 = inheritedComponents
			local _exp = id
			instances = {}
			local _instances = instances
			_inheritedComponents_1[_exp] = _instances
		end
		local _reverseComponentsMapping = self.reverseComponentsMapping
		local _id_1 = id
		local inheritedLookup = _reverseComponentsMapping[_id_1]
		if not inheritedLookup then
			local _reverseComponentsMapping_1 = self.reverseComponentsMapping
			local _exp = id
			inheritedLookup = {}
			local _inheritedLookup = inheritedLookup
			_reverseComponentsMapping_1[_exp] = _inheritedLookup
		end
		local _instances = instances
		local _value = value
		_instances[_value] = true
		local _inheritedLookup = inheritedLookup
		local _value_1 = value
		_inheritedLookup[_value_1] = true
	end
	function Components:removeIdMapping(instance, value, id)
		local _activeInheritedComponents = self.activeInheritedComponents
		local _instance = instance
		local inheritedComponents = _activeInheritedComponents[_instance]
		if not inheritedComponents then
			return nil
		end
		local _id = id
		local instances = inheritedComponents[_id]
		if not instances then
			return nil
		end
		local _reverseComponentsMapping = self.reverseComponentsMapping
		local _id_1 = id
		local inheritedLookup = _reverseComponentsMapping[_id_1]
		if not inheritedLookup then
			return nil
		end
		local _value = value
		instances[_value] = nil
		local _value_1 = value
		inheritedLookup[_value_1] = nil
		-- ▼ ReadonlySet.size ▼
		local _size = 0
		for _ in inheritedLookup do
			_size += 1
		end
		-- ▲ ReadonlySet.size ▲
		if _size == 0 then
			local _reverseComponentsMapping_1 = self.reverseComponentsMapping
			local _id_2 = id
			_reverseComponentsMapping_1[_id_2] = nil
		end
		-- ▼ ReadonlySet.size ▼
		local _size_1 = 0
		for _ in instances do
			_size_1 += 1
		end
		-- ▲ ReadonlySet.size ▲
		if _size_1 == 0 then
			local _id_2 = id
			inheritedComponents[_id_2] = nil
		end
		-- ▼ ReadonlyMap.size ▼
		local _size_2 = 0
		for _ in inheritedComponents do
			_size_2 += 1
		end
		-- ▲ ReadonlyMap.size ▲
		if _size_2 == 0 then
			local _activeInheritedComponents_1 = self.activeInheritedComponents
			local _instance_1 = instance
			_activeInheritedComponents_1[_instance_1] = nil
		end
	end
	function Components:canCreateComponentEager(instance, component)
		local _components = self.components
		local _component = component
		local componentInfo = _components[_component]
		if not componentInfo then
			return false
		end
		local tag = componentInfo.config.tag
		if tag ~= nil and (instance.Parent and CollectionService:HasTag(instance, tag)) then
			local tracker = self:getComponentTracker(component)
			return tracker:checkInstance(instance)
		end
	end
	function Components:getDependencyResolutionOptions(componentInfo, instance)
		if #componentInfo.componentDependencies == 0 then
			return nil
		end
		return {
			handle = function(id)
				local _idToObj = Reflect.idToObj
				local _id = id
				local ctor = _idToObj[_id]
				if ctor and Modding.getDecorator(ctor, nil, "$c:init@Component") then
					local component = self:getComponent(instance, ctor)
					if component == nil then
						local name = instance:GetFullName()
						error("Could not resolve component '" .. (id .. ("' while constructing '" .. (componentInfo.identifier .. ("' (" .. (name .. ")"))))))
					end
					return component
				end
			end,
		}
	end
	function Components:getComponent(instance, componentSpecifier)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _arg1 = "Could not find component from specifier: " .. tostring(componentSpecifier)
		assert(component, _arg1)
		local _activeComponents = self.activeComponents
		local _instance = instance
		local activeComponents = _activeComponents[_instance]
		if activeComponents then
			local activeComponent = activeComponents[component]
			if activeComponent then
				return activeComponent
			end
		end
		if self:canCreateComponentEager(instance, component) then
			return self:addComponent(instance, component, true)
		end
	end
	function Components:getComponents(instance, componentSpecifier)
		local componentIdentifier = self:getIdFromSpecifier(componentSpecifier)
		if componentIdentifier == nil then
			return {}
		end
		local _activeInheritedComponents = self.activeInheritedComponents
		local _instance = instance
		local activeComponents = _activeInheritedComponents[_instance]
		if not activeComponents then
			return {}
		end
		local componentsSet = activeComponents[componentIdentifier]
		if not componentsSet then
			return {}
		end
		local _array = {}
		local _length = #_array
		for _v in componentsSet do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	function Components:addComponent(instance, componentSpecifier, skipInstanceCheck)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _arg1 = "Could not find component from specifier: " .. tostring(componentSpecifier)
		assert(component, _arg1)
		local componentInfo = self.components[component]
		assert(componentInfo, "Provided componentSpecifier does not exist")
		local attributeGuards = self:getAttributeGuards(component)
		local attributes = self:getAttributes(instance, componentInfo, attributeGuards)
		if skipInstanceCheck ~= true then
			local instanceGuard = self:getConfigValue(component, "instanceGuard")
			if instanceGuard ~= nil then
				local _arg0 = instanceGuard(instance)
				local _arg1_1 = instance:GetFullName() .. (" did not pass instance guard check for '" .. (componentInfo.identifier .. "'"))
				assert(_arg0, _arg1_1)
			end
		end
		local _activeComponents = self.activeComponents
		local _instance = instance
		local activeComponents = _activeComponents[_instance]
		if not activeComponents then
			local _activeComponents_1 = self.activeComponents
			local _exp = instance
			activeComponents = {}
			local _activeComponents_2 = activeComponents
			_activeComponents_1[_exp] = _activeComponents_2
		end
		local _activeInheritedComponents = self.activeInheritedComponents
		local _instance_1 = instance
		local inheritedComponents = _activeInheritedComponents[_instance_1]
		if not inheritedComponents then
			local _activeInheritedComponents_1 = self.activeInheritedComponents
			local _exp = instance
			inheritedComponents = {}
			local _inheritedComponents = inheritedComponents
			_activeInheritedComponents_1[_exp] = _inheritedComponents
		end
		local existingComponent = activeComponents[component]
		if existingComponent ~= nil then
			return existingComponent
		end
		local resolutionOptions = self:getDependencyResolutionOptions(componentInfo, instance)
		local _binding = Modding.createDeferredDependency(component, resolutionOptions)
		local componentInstance = _binding[1]
		local construct = _binding[2]
		activeComponents[component] = componentInstance
		for _, parentClass in self:getOrderedParents(component) do
			local parentId = Reflect.getOwnMetadata(parentClass, "identifier")
			if parentId == nil then
				continue
			end
			self:addIdMapping(componentInstance, parentId, inheritedComponents)
		end
		local implementedList = Reflect.getMetadatas(component, "flamework:implements")
		for _, implemented in implementedList do
			for _1, id in implemented do
				self:addIdMapping(componentInstance, id, inheritedComponents)
			end
		end
		self:setupComponent(instance, attributes, componentInstance, construct, componentInfo)
		return componentInstance
	end
	function Components:removeComponent(instance, componentSpecifier)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _arg1 = "Could not find component from specifier: " .. tostring(componentSpecifier)
		assert(component, _arg1)
		local _activeComponents = self.activeComponents
		local _instance = instance
		local activeComponents = _activeComponents[_instance]
		if not activeComponents then
			return nil
		end
		local existingComponent = activeComponents[component]
		if not existingComponent then
			return nil
		end
		existingComponent:destroy()
		activeComponents[component] = nil
		for _, parentClass in self:getOrderedParents(component) do
			local parentId = Reflect.getOwnMetadata(parentClass, "identifier")
			if parentId == nil then
				continue
			end
			self:removeIdMapping(instance, existingComponent, parentId)
		end
		local implementedList = Reflect.getMetadatas(component, "flamework:implements")
		for _, implemented in implementedList do
			for _1, id in implemented do
				self:removeIdMapping(instance, existingComponent, id)
			end
		end
		-- ▼ ReadonlyMap.size ▼
		local _size = 0
		for _ in activeComponents do
			_size += 1
		end
		-- ▲ ReadonlyMap.size ▲
		if _size == 0 then
			local _activeComponents_1 = self.activeComponents
			local _instance_1 = instance
			_activeComponents_1[_instance_1] = nil
		end
	end
	function Components:getAllComponents(componentSpecifier)
		local componentIdentifier = self:getIdFromSpecifier(componentSpecifier)
		if componentIdentifier == nil then
			return {}
		end
		local reverseMapping = self.reverseComponentsMapping[componentIdentifier]
		if not reverseMapping then
			return {}
		end
		local _array = {}
		local _length = #_array
		for _v in reverseMapping do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	function Components:waitForComponent(instance, componentSpecifier)
		local component = self:getComponentFromSpecifier(componentSpecifier)
		local _arg1 = "Could not find component from specifier: " .. tostring(componentSpecifier)
		assert(component, _arg1)
		return TS.Promise.new(function(resolve, _, onCancel)
			local existingComponent = self:getComponent(instance, componentSpecifier)
			if existingComponent ~= nil then
				return resolve(existingComponent)
			end
			local _componentWaiters = self.componentWaiters
			local _instance = instance
			local instanceWaiters = _componentWaiters[_instance]
			if not instanceWaiters then
				local _componentWaiters_1 = self.componentWaiters
				local _exp = instance
				instanceWaiters = {}
				local _instanceWaiters = instanceWaiters
				_componentWaiters_1[_exp] = _instanceWaiters
			end
			local componentWaiters = instanceWaiters[component]
			if not componentWaiters then
				local _instanceWaiters = instanceWaiters
				componentWaiters = {}
				local _componentWaiters_1 = componentWaiters
				_instanceWaiters[component] = _componentWaiters_1
			end
			onCancel(function()
				local _componentWaiters_1 = componentWaiters
				local _resolve = resolve
				_componentWaiters_1[_resolve] = nil
				-- ▼ ReadonlySet.size ▼
				local _size = 0
				for _1 in componentWaiters do
					_size += 1
				end
				-- ▲ ReadonlySet.size ▲
				if _size == 0 then
					instanceWaiters[component] = nil
				end
				-- ▼ ReadonlyMap.size ▼
				local _size_1 = 0
				for _1 in instanceWaiters do
					_size_1 += 1
				end
				-- ▲ ReadonlyMap.size ▲
				if _size_1 == 0 then
					local _componentWaiters_2 = self.componentWaiters
					local _instance_1 = instance
					_componentWaiters_2[_instance_1] = nil
				end
			end)
			local _componentWaiters_1 = componentWaiters
			local _resolve = resolve
			_componentWaiters_1[_resolve] = true
		end)
	end
end
-- (Flamework) Components metadata
Reflect.defineMetadata(Components, "identifier", "$c:init@Components")
Reflect.defineMetadata(Components, "flamework:implements", { "$:flamework@OnInit", "$:flamework@OnStart" })
Reflect.decorate(Components, "$:flamework@Service", Service, { {
	loadOrder = 0,
} })
Reflect.decorate(Components, "$:flamework@Controller", Controller, { {
	loadOrder = 0,
} })
return {
	Component = Component,
	BaseComponent = BaseComponent,
	Components = Components,
}
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="16">
                <Properties>
                  <string name="Name">componentTracker</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local CollectionService = TS.import(script, TS.getModule(script, "@rbxts", "services")).CollectionService
local ComponentTracker
do
	ComponentTracker = setmetatable({}, {
		__tostring = function()
			return "ComponentTracker"
		end,
	})
	ComponentTracker.__index = ComponentTracker
	function ComponentTracker.new(...)
		local self = setmetatable({}, ComponentTracker)
		return self:constructor(...) or self
	end
	function ComponentTracker:constructor(identifier, criteria)
		self.identifier = identifier
		self.criteria = criteria
		self.instances = {}
	end
	function ComponentTracker:getInstanceTracker(instance, create)
		if create == nil then
			create = true
		end
		local _instances = self.instances
		local _instance = instance
		local tracker = _instances[_instance]
		if not tracker and create then
			tracker = {
				unmetCriteria = {},
				listeners = {},
				cleanup = {},
				isQualified = true,
			}
			local _instances_1 = self.instances
			local _instance_1 = instance
			local _tracker = tracker
			_instances_1[_instance_1] = _tracker
		end
		return tracker
	end
	function ComponentTracker:updateListeners(instance, tracker)
		local isQualified = next(tracker.unmetCriteria) == nil
		if isQualified ~= tracker.isQualified then
			tracker.isQualified = isQualified
			for listener in tracker.listeners do
				listener(isQualified, instance)
			end
			local warningThread = tracker.timeoutWarningThread
			if isQualified and warningThread then
				tracker.timeoutWarningThread = nil
				task.cancel(warningThread)
			end
		end
	end
	function ComponentTracker:setupTracker(instance, tracker)
		local _binding = self.criteria
		local typeGuard = _binding.typeGuard
		local typeGuardPoll = _binding.typeGuardPoll
		local dependencies = _binding.dependencies
		if typeGuard and typeGuardPoll then
			local addedConnection
			local removingConnection
			local connectRemoving
			local connectAdded = function()
				if removingConnection then
					removingConnection:Disconnect()
					removingConnection = nil
				end
				local isScheduled = false
				addedConnection = instance.DescendantAdded:Connect(function()
					if not isScheduled then
						isScheduled = true
						task.defer(function()
							isScheduled = false
							if typeGuard(instance) then
								connectRemoving()
								tracker.unmetCriteria["type guard"] = nil
								self:updateListeners(instance, tracker)
							end
						end)
					end
				end)
			end
			connectRemoving = function()
				if addedConnection then
					addedConnection:Disconnect()
					addedConnection = nil
				end
				local isScheduled = false
				removingConnection = instance.DescendantRemoving:Connect(function()
					if not isScheduled then
						isScheduled = true
						task.defer(function()
							isScheduled = false
							if not typeGuard(instance) then
								connectAdded()
								tracker.unmetCriteria["type guard"] = true
								self:updateListeners(instance, tracker)
							end
						end)
					end
				end)
			end
			local _cleanup = tracker.cleanup
			local _arg0 = function()
				local _result = addedConnection
				if _result ~= nil then
					_result:Disconnect()
				end
				local _result_1 = removingConnection
				if _result_1 ~= nil then
					_result_1:Disconnect()
				end
			end
			_cleanup[_arg0] = true
			if tracker.unmetCriteria["type guard"] ~= nil then
				connectAdded()
			else
				connectRemoving()
			end
		end
		if dependencies then
			for _, dependency in dependencies do
				local listener = function(isQualified)
					if isQualified then
						tracker.unmetCriteria[dependency] = nil
					else
						tracker.unmetCriteria[dependency] = true
					end
					self:updateListeners(instance, tracker)
				end
				dependency:trackInstance(instance, listener)
				local _cleanup = tracker.cleanup
				local _arg0 = function()
					dependency:untrackInstance(instance, listener)
				end
				_cleanup[_arg0] = true
			end
		end
		if not tracker.isQualified and self.criteria.warningTimeout ~= 0 then
			local _fn = task
			local _condition = self.criteria.warningTimeout
			if _condition == nil then
				_condition = 5
			end
			tracker.timeoutWarningThread = _fn.delay(_condition, function()
				local reasons = {}
				for criteria in tracker.unmetCriteria do
					if type(criteria) == "string" then
						table.insert(reasons, criteria)
					end
				end
				if dependencies then
					for _, dependency in dependencies do
						if tracker.unmetCriteria[dependency] ~= nil then
							local _arg0 = "dependency '" .. (dependency.identifier .. "'")
							table.insert(reasons, _arg0)
						end
					end
				end
				warn("[Flamework] Infinite yield possible on instance '" .. (instance:GetFullName() .. "'"))
				warn("Waiting for component '" .. (self.identifier .. "'"))
				warn("Waiting for the following criteria: " .. table.concat(reasons, ", "))
			end)
		end
	end
	function ComponentTracker:testInstance(instance, tracker)
		local result = true
		if self.criteria.dependencies then
			for _, dependency in self.criteria.dependencies do
				if not dependency:checkInstance(instance) then
					result = false
					if tracker then
						tracker.unmetCriteria[dependency] = true
						self:updateListeners(instance, tracker)
					else
						return result
					end
				end
			end
		end
		if self.criteria.typeGuard then
			if not self.criteria.typeGuard(instance) then
				result = false
				if tracker then
					tracker.unmetCriteria["type guard"] = true
					self:updateListeners(instance, tracker)
				else
					return result
				end
			end
		end
		if self.criteria.tag ~= nil then
			if not CollectionService:HasTag(instance, self.criteria.tag) then
				result = false
				if tracker then
					tracker.unmetCriteria["CollectionService tag"] = true
					self:updateListeners(instance, tracker)
				else
					return result
				end
			end
		end
		return result
	end
	function ComponentTracker:setHasTag(instance, hasTag)
		local tracker = self:getInstanceTracker(instance, false)
		if tracker then
			if hasTag then
				tracker.unmetCriteria["CollectionService tag"] = nil
			else
				tracker.unmetCriteria["CollectionService tag"] = true
			end
			self:updateListeners(instance, tracker)
		end
	end
	function ComponentTracker:checkInstance(instance)
		local tracker = self:getInstanceTracker(instance, false)
		if tracker then
			return tracker.isQualified
		end
		return self:testInstance(instance, tracker)
	end
	function ComponentTracker:isTracked(instance)
		local _instances = self.instances
		local _instance = instance
		return _instances[_instance] ~= nil
	end
	function ComponentTracker:trackInstance(instance, listener)
		local _instances = self.instances
		local _instance = instance
		local isNewInstance = not (_instances[_instance] ~= nil)
		local tracker = self:getInstanceTracker(instance)
		if isNewInstance then
			self:testInstance(instance, tracker)
			self:setupTracker(instance, tracker)
		end
		local _listeners = tracker.listeners
		local _listener = listener
		_listeners[_listener] = true
		listener(tracker.isQualified, instance)
	end
	function ComponentTracker:untrackInstance(instance, listener)
		local tracker = self:getInstanceTracker(instance, false)
		if tracker then
			local _listeners = tracker.listeners
			local _listener = listener
			_listeners[_listener] = nil
			if next(tracker.listeners) == nil then
				for cleanup in tracker.cleanup do
					cleanup()
				end
				local _instances = self.instances
				local _instance = instance
				_instances[_instance] = nil
			end
		end
	end
end
return {
	ComponentTracker = ComponentTracker,
}
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="17">
            <Properties>
              <string name="Name">core</string>
            </Properties>
            <Item class="ModuleScript" referent="18">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local exports = {}
exports.Reflect = TS.import(script, script, "reflect").Reflect
exports.Modding = TS.import(script, script, "modding").Modding
local _flamework = TS.import(script, script, "flamework")
exports.Controller = _flamework.Controller
exports.Dependency = _flamework.Dependency
exports.External = _flamework.External
exports.Service = _flamework.Service
exports.Flamework = _flamework.Flamework
return exports
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="19">
                <Properties>
                  <string name="Name">flamework</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local Players = _services.Players
local RunService = _services.RunService
local Metadata = TS.import(script, script.Parent, "metadata").Metadata
local Modding = TS.import(script, script.Parent, "modding").Modding
local Reflect = TS.import(script, script.Parent, "reflect").Reflect
local ArtificialDependency, Flamework
local Flamework = {}
do
	local _container = Flamework
	local flameworkConfig = {
		isDefault = true,
	}
	_container.flameworkConfig = flameworkConfig
	_container.isInitialized = false
	local isPreloading = false
	-- * @hidden
	local hasFlameworkIgnited
	local function resolveDependency(id)
		if isPreloading then
			local source, line = debug.info(2, "sl")
			warn("[Flamework] Attempting to load dependency '" .. (id .. "' during preloading."))
			warn("This is prone to race conditions and is not guaranteed to succeed.")
			warn("Script '" .. (source .. ("', Line " .. tostring(line))))
		elseif not hasFlameworkIgnited and Metadata.gameConfig.disableDependencyWarnings ~= true then
			local source, line = debug.info(2, "sl")
			warn("[Flamework] Dependency '" .. (id .. "' was loaded before ignition."))
			warn("This is considered bad practice and should be avoided.")
			warn("You can disable this warning in flamework.json")
			warn("Script '" .. (source .. ("', Line " .. tostring(line))))
		end
		return Modding.resolveDependency(ArtificialDependency, id, 0, {})
	end
	_container.resolveDependency = resolveDependency
	-- * @hidden
	local logIfVerbose
	local function _addPaths(...)
		local args = { ... }
		local preloadPaths = {}
		for _, arg in args do
			local service = table.remove(arg, 1)
			local currentPath = game:GetService(service)
			if service == "StarterPlayer" then
				if arg[1] ~= "StarterPlayerScripts" then
					error("StarterPlayer only supports StarterPlayerScripts")
				end
				if not RunService:IsClient() then
					error("The server cannot load StarterPlayer content")
				end
				currentPath = Players.LocalPlayer:WaitForChild("PlayerScripts")
				table.remove(arg, 1)
			end
			do
				local i = 0
				local _shouldIncrement = false
				while true do
					if _shouldIncrement then
						i += 1
					else
						_shouldIncrement = true
					end
					if not (i < #arg) then
						break
					end
					currentPath = currentPath:WaitForChild(arg[i + 1])
				end
			end
			local _currentPath = currentPath
			table.insert(preloadPaths, _currentPath)
		end
		local preload = function(moduleScript)
			isPreloading = true
			local start = os.clock()
			local success, value = pcall(require, moduleScript)
			local endTime = math.floor((os.clock() - start) * 1000)
			isPreloading = false
			if not success then
				error(moduleScript:GetFullName() .. (" failed to preload (" .. (tostring(endTime) .. ("ms): " .. tostring(value)))))
			end
		end
		for _, path in preloadPaths do
			logIfVerbose("Preloading directory " .. path:GetFullName())
			if path:IsA("ModuleScript") then
				preload(path)
			end
			for _1, instance in path:GetDescendants() do
				if instance:IsA("ModuleScript") then
					preload(instance)
				end
			end
		end
	end
	_container._addPaths = _addPaths
	-- * @hidden
	local function _implements(object, id)
		local _exp = Reflect.getMetadatas(object, "flamework:implements")
		local _arg0 = function(impl)
			local _impl = impl
			local _id = id
			return table.find(_impl, _id) ~= nil
		end
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		for _k, _v in _exp do
			if _arg0(_v, _k - 1, _exp) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		return _result
	end
	_container._implements = _implements
	function logIfVerbose(...)
		local args = { ... }
		if Metadata.getLogLevel() == "verbose" then
			print("[Flamework (verbose)]", unpack(args))
		end
	end
	local function isConstructor(obj)
		return obj.new ~= nil and obj.constructor ~= nil
	end
	local function getIdentifier(obj, suffix)
		if suffix == nil then
			suffix = ""
		end
		local _condition = Reflect.getMetadata(obj, "identifier")
		if _condition == nil then
			_condition = "UnidentifiedFlameworkListener" .. suffix
		end
		return _condition
	end
	-- This returns a Map rather than an Array because table.sort is unstable and will not preserve element order.
	local function topologicalSort(objects)
		-- This implementation ignores circular dependency trees.
		local currentSize = 0
		local sorted = {}
		local visited = {}
		local visitor
		visitor = function(node)
			local _node = node
			if visited[_node] ~= nil then
				return nil
			end
			local _node_1 = node
			visited[_node_1] = true
			local _idToObj = Reflect.idToObj
			local _node_2 = node
			local object = _idToObj[_node_2]
			if not object then
				return nil
			end
			local dependencies = Reflect.getMetadata(object, "flamework:parameters")
			for _, dependency in dependencies or {} do
				visitor(dependency)
			end
			local _exp = node
			local _original = currentSize
			currentSize += 1
			sorted[_exp] = _original
		end
		for _, node in objects do
			visitor(node)
		end
		return sorted
	end
	local externalClasses = {}
	local isProfiling = Metadata.isProfiling()
	local function profilingThread(func, identifier)
		-- `profilebegin` will end when this thread dies.
		debug.profilebegin(identifier)
		debug.setmemorycategory(identifier)
		func()
	end
	local function profileYielding(func, identifier)
		if isProfiling then
			task.spawn(profilingThread, func, identifier)
		else
			task.spawn(func)
		end
	end
	--[[
		*
		* Allow an external module to be bootstrapped by Flamework.ignite()
	]]
	local function registerExternalClass(ctor)
		local _ctor = ctor
		externalClasses[_ctor] = true
	end
	_container.registerExternalClass = registerExternalClass
	hasFlameworkIgnited = false
	--[[
		*
		* Initialize Flamework.
		*
		* This will start up the lifecycle events on all currently registered
		* classes.
		*
		* You should preload all necessary directories before calling this
		* as newly registered classes will not run their lifecycle events.
		*
		* @returns All the dependencies that have been loaded.
	]]
	local function ignite(patchedConfig)
		if hasFlameworkIgnited then
			error("Flamework.ignite() should only be called once")
		end
		hasFlameworkIgnited = true
		if patchedConfig then
			for key, value in pairs(patchedConfig) do
				flameworkConfig[key] = value
			end
		end
		for ctor in Reflect.objToId do
			if not isConstructor(ctor) then
				continue
			end
			if not Reflect.getMetadata(ctor, "flamework:singleton") then
				continue
			end
			local isPatched = Reflect.getOwnMetadata(ctor, "flamework:isPatched")
			if flameworkConfig.loadOverride and (not (table.find(flameworkConfig.loadOverride, ctor) ~= nil) and not isPatched) then
				continue
			end
			local isExternal = Reflect.getOwnMetadata(ctor, "flamework:isExternal")
			if isExternal and not (externalClasses[ctor] ~= nil) then
				continue
			end
			Modding.resolveSingleton(ctor)
			logIfVerbose("Resolving singleton " .. tostring(ctor))
		end
		local dependencies = {}
		for ctor, dependency in Modding.getSingletons() do
			local _condition = Reflect.getMetadata(ctor, "flamework:loadOrder")
			if _condition == nil then
				_condition = 1
			end
			local loadOrder = _condition
			local _arg0 = { dependency, loadOrder }
			table.insert(dependencies, _arg0)
		end
		local _arg0 = function(_param)
			local obj = _param[1]
			return getIdentifier(obj)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#dependencies)
		for _k, _v in dependencies do
			_newValue[_k] = _arg0(_v, _k - 1, dependencies)
		end
		-- ▲ ReadonlyArray.map ▲
		local sortedDependencies = topologicalSort(_newValue)
		local start = {}
		local init = {}
		local tick = {}
		local render = {}
		local physics = {}
		local _arg0_1 = function(_param, _param_1)
			local depA = _param[1]
			local aOrder = _param[2]
			local depB = _param_1[1]
			local bOrder = _param_1[2]
			if aOrder ~= bOrder then
				return aOrder < bOrder
			end
			local _arg0_2 = getIdentifier(depA)
			local aIndex = sortedDependencies[_arg0_2]
			local _arg0_3 = getIdentifier(depB)
			local bIndex = sortedDependencies[_arg0_3]
			return aIndex < bIndex
		end
		table.sort(dependencies, _arg0_1)
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnTick")
			tick[_object] = _arg1
			return tick
		end, "$:flamework@OnTick")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnPhysics")
			physics[_object] = _arg1
			return physics
		end, "$:flamework@OnPhysics")
		Modding.onListenerAdded(function(object)
			local _object = object
			local _arg1 = getIdentifier(object, "/OnRender")
			render[_object] = _arg1
			return render
		end, "$:flamework@OnRender")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = tick[_object] ~= nil
			tick[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnTick")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = physics[_object] ~= nil
			physics[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnPhysics")
		Modding.onListenerRemoved(function(object)
			local _object = object
			-- ▼ Map.delete ▼
			local _valueExisted = render[_object] ~= nil
			render[_object] = nil
			-- ▲ Map.delete ▲
			return _valueExisted
		end, "$:flamework@OnRender")
		for _, _binding in dependencies do
			local dependency = _binding[1]
			if Flamework._implements(dependency, "$:flamework@OnInit") then
				local _arg0_2 = { dependency, getIdentifier(dependency) }
				table.insert(init, _arg0_2)
			end
			if Flamework._implements(dependency, "$:flamework@OnStart") then
				local _arg0_2 = { dependency, getIdentifier(dependency) }
				table.insert(start, _arg0_2)
			end
		end
		for _, _binding in init do
			local dependency = _binding[1]
			local identifier = _binding[2]
			if isProfiling then
				debug.setmemorycategory(identifier)
			end
			logIfVerbose("OnInit " .. identifier)
			local initResult = dependency:onInit()
			if TS.Promise.is(initResult) then
				local status, value = initResult:awaitStatus()
				if status == TS.Promise.Status.Rejected then
					error("OnInit failed for dependency '" .. (identifier .. ("'. " .. tostring(value))))
				end
			end
		end
		debug.resetmemorycategory()
		_container.isInitialized = true
		RunService.Heartbeat:Connect(function(dt)
			for dependency, identifier in tick do
				profileYielding(function()
					return dependency:onTick(dt)
				end, identifier)
			end
		end)
		RunService.Stepped:Connect(function(time, dt)
			for dependency, identifier in physics do
				profileYielding(function()
					return dependency:onPhysics(dt, time)
				end, identifier)
			end
		end)
		if RunService:IsClient() then
			RunService.RenderStepped:Connect(function(dt)
				for dependency, identifier in render do
					profileYielding(function()
						return dependency:onRender(dt)
					end, identifier)
				end
			end)
		end
		for _, _binding in start do
			local dependency = _binding[1]
			local identifier = _binding[2]
			logIfVerbose("OnStart " .. identifier)
			profileYielding(function()
				return dependency:onStart()
			end, identifier)
		end
	end
	_container.ignite = ignite
	--[[
		*
		* Preload the specified paths by requiring all ModuleScript descendants.
	]]
	--[[
		*
		* Preload the specified paths by requiring all ModuleScript descendants.
	]]
	--[[
		*
		* Retrieve the identifier for the specified type.
	]]
	--[[
		*
		* Check if the constructor implements the specified interface.
	]]
	--[[
		*
		* Check if object implements the specified interface.
	]]
	--[[
		*
		* Creates a type guard from any arbitrary type.
	]]
	--[[
		*
		* Hash a function using the method used internally by Flamework.
		* If a context is provided, then Flamework will create a new hash
		* if the specified string does not have one in that context.
		* @param str The string to hash
		* @param context A scope for the hash
	]]
	--[[
		*
		* Utility for use in test suites, not recommended for anything else.
	]]
	local Testing = {}
	do
		local _container_1 = Testing
		local function patchDependency(patchedClass, id)
			if id == nil then
				error("Patching failed, no ID")
			end
			local _idToObj = Reflect.idToObj
			local _id = id
			local idCtor = _idToObj[_id]
			if idCtor == nil then
				error("Dependency " .. (id .. " was not found and cannot be patched."))
			end
			if Modding.getSingletons()[idCtor] ~= nil then
				error(id .. " has already been resolved, continuing is unsafe")
			end
			local objMetadata = Reflect.metadata[idCtor]
			if not objMetadata then
				error("Dependency " .. (id .. " has no existing metadata."))
			end
			Reflect.defineMetadata(idCtor, "flamework:isPatched", true)
			Reflect.metadata[idCtor] = nil
			local _metadata = Reflect.metadata
			local _patchedClass = patchedClass
			_metadata[_patchedClass] = objMetadata
			local _objToId = Reflect.objToId
			local _patchedClass_1 = patchedClass
			local _id_1 = id
			_objToId[_patchedClass_1] = _id_1
			local _idToObj_1 = Reflect.idToObj
			local _id_2 = id
			local _patchedClass_2 = patchedClass
			_idToObj_1[_id_2] = _patchedClass_2
		end
		_container_1.patchDependency = patchDependency
	end
	_container.Testing = Testing
end
--[[
	*
	* An internal class used for resolving the Dependency<T> macro.
]]
do
	ArtificialDependency = setmetatable({}, {
		__tostring = function()
			return "ArtificialDependency"
		end,
	})
	ArtificialDependency.__index = ArtificialDependency
	function ArtificialDependency.new(...)
		local self = setmetatable({}, ArtificialDependency)
		return self:constructor(...) or self
	end
	function ArtificialDependency:constructor()
	end
end
Reflect.defineMetadata(ArtificialDependency, "identifier", "$:flamework@ArtificialDependency")
Reflect.defineMetadata(ArtificialDependency, "flamework:isArtificial", true)
--[[
	*
	* Register a class as a Service.
	*
	* @server
	* @metadata flamework:implements flamework:parameters injectable
]]
local Service = Modding.createDecorator("Class", function(descriptor, _param)
	local cfg = _param[1]
	if RunService:IsServer() then
		Reflect.defineMetadata(descriptor.object, "flamework:singleton", true)
		local _fn = Reflect
		local _exp = descriptor.object
		local _result = cfg
		if _result ~= nil then
			_result = _result.loadOrder
		end
		_fn.defineMetadata(_exp, "flamework:loadOrder", _result)
	end
end)
--[[
	*
	* Register a class as a Controller.
	*
	* @client
	* @metadata flamework:implements flamework:parameters injectable
]]
local Controller = Modding.createDecorator("Class", function(descriptor, _param)
	local cfg = _param[1]
	if RunService:IsClient() then
		Reflect.defineMetadata(descriptor.object, "flamework:singleton", true)
		local _fn = Reflect
		local _exp = descriptor.object
		local _result = cfg
		if _result ~= nil then
			_result = _result.loadOrder
		end
		_fn.defineMetadata(_exp, "flamework:loadOrder", _result)
	end
end)
--[[
	*
	* Marks this class as an external class.
	*
	* External classes are designed for packages and won't be
	* bootstrapped unless explicitly specified. Excluding this
	* inside of a package will make the class load as long as
	* it has been loaded.
]]
local External = Modding.createDecorator("Class", function(descriptor)
	Reflect.defineMetadata(descriptor.object, "flamework:isExternal", true)
end)
--[[
	*
	* Hook into the OnInit lifecycle event.
]]
--[[
	*
	* Hook into the OnStart lifecycle event.
]]
--[[
	*
	* Hook into the OnTick lifecycle event.
	* Equivalent to: RunService.Heartbeat
]]
--[[
	*
	* Hook into the OnPhysics lifecycle event.
	* Equivalent to: RunService.Stepped
]]
--[[
	*
	* Hook into the OnRender lifecycle event.
	* Equivalent to: RunService.RenderStepped
	*
	* @client
]]
return {
	Flamework = Flamework,
	Service = Service,
	Controller = Controller,
	External = External,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="20">
                <Properties>
                  <string name="Name">metadata</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
--[[
	*
	* Metadata exposed by the Flamework transformer.
]]
local Metadata = {}
do
	local _container = Metadata
	--[[
		*
		* Runtime metadata generated by the transformer
	]]
	--[[
		*
		* Runtime metadata generated by the transformer
	]]
	local function getConfigContainer()
		local current = script
		while current do
			local flamework = current:FindFirstChild("flamework")
			if flamework then
				local metadata = flamework:FindFirstChild("config")
				if metadata then
					return require(metadata)
				end
			end
			current = current.Parent
		end
	end
	local configContainer
	local function getConfig(packageId)
		local _result
		if packageId == nil then
			local _result_1 = configContainer
			if _result_1 ~= nil then
				_result_1 = _result_1.game
			end
			_result = _result_1
		else
			local _result_1 = configContainer
			if _result_1 ~= nil then
				local _packages = _result_1.packages
				local _packageId = packageId
				_result_1 = _packages[_packageId]
			end
			_result = _result_1
		end
		return _result
	end
	configContainer = getConfigContainer()
	_container.configContainer = configContainer
	local _result = configContainer
	if _result ~= nil then
		_result = _result.game
	end
	local _condition = _result
	if _condition == nil then
		_condition = {}
	end
	local gameConfig = _condition
	_container.gameConfig = gameConfig
	local function getLogLevel(packageId)
		local config = getConfig(packageId)
		if not config or config.logLevel == nil then
			return "none"
		end
		return config.logLevel
	end
	_container.getLogLevel = getLogLevel
	local function isProfiling(packageId)
		local config = getConfig(packageId)
		if not config or config.profiling == nil then
			return RunService:IsStudio()
		end
		return config.profiling
	end
	_container.isProfiling = isProfiling
end
return {
	Metadata = Metadata,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="21">
                <Properties>
                  <string name="Name">modding</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "signal"))
local Reflect = TS.import(script, script.Parent, "reflect").Reflect
local getDeferredConstructor, isConstructor
local Modding = {}
do
	local _container = Modding
	local listeners = {}
	local lifecycleListeners = {}
	local decoratorListeners = {}
	local listenerAdded = Signal.new()
	local listenerRemoved = Signal.new()
	local listenerAddedEvents = {}
	local listenerRemovedEvents = {}
	local dependencyResolution = {}
	local resolvedSingletons = {}
	local loadingList = {}
	--[[
		*
		* Registers a listener for lifecycle events.
	]]
	local function addListener(object)
		local listener = {
			eventIds = {},
			involvement = {},
		}
		for _, lifecycleEvents in Reflect.getMetadatas(object, "flamework:implements") do
			for _1, lifecycleEvent in lifecycleEvents do
				if listener.eventIds[lifecycleEvent] ~= nil then
					continue
				end
				local lifecycleListener = lifecycleListeners[lifecycleEvent]
				if not lifecycleListener then
					lifecycleListener = {}
					local _lifecycleListener = lifecycleListener
					lifecycleListeners[lifecycleEvent] = _lifecycleListener
				end
				local _lifecycleListener = lifecycleListener
				local _object = object
				_lifecycleListener[_object] = true
				listener.eventIds[lifecycleEvent] = true
				local _involvement = listener.involvement
				local _lifecycleListener_1 = lifecycleListener
				table.insert(_involvement, _lifecycleListener_1)
				local _result = listenerAddedEvents[lifecycleEvent]
				if _result ~= nil then
					_result:Fire(object)
				end
			end
		end
		local decorators = Reflect.getMetadata(object, "flamework:decorators")
		if decorators then
			for _, decorator in decorators do
				if listener.eventIds[decorator] ~= nil then
					continue
				end
				local decoratorListener = decoratorListeners[decorator]
				if not decoratorListener then
					decoratorListener = {}
					local _decoratorListener = decoratorListener
					decoratorListeners[decorator] = _decoratorListener
				end
				local _decoratorListener = decoratorListener
				local _object = object
				_decoratorListener[_object] = true
				listener.eventIds[decorator] = true
				local _involvement = listener.involvement
				local _decoratorListener_1 = decoratorListener
				table.insert(_involvement, _decoratorListener_1)
				local _result = listenerAddedEvents[decorator]
				if _result ~= nil then
					_result:Fire(object)
				end
			end
		end
		local _object = object
		listeners[_object] = listener
		listenerAdded:Fire(object)
	end
	_container.addListener = addListener
	--[[
		*
		* Removes a listener for lifecycle events and decorators.
	]]
	local function removeListener(object)
		local _object = object
		local listener = listeners[_object]
		if not listener then
			return nil
		end
		for _, set in listener.involvement do
			local _object_1 = object
			set[_object_1] = nil
		end
		for id in listener.eventIds do
			local _result = listenerRemovedEvents[id]
			if _result ~= nil then
				_result:Fire(object)
			end
		end
		local _object_1 = object
		listeners[_object_1] = nil
		listenerRemoved:Fire(object)
	end
	_container.removeListener = removeListener
	--[[
		*
		* Registers a listener added event.
		* Fires whenever any listener is added.
		*
		* Fires for all existing listeners.
	]]
	--[[
		*
		* Registers a listener added event.
		* Fires whenever a listener has a decorator with the specified ID.
		*
		* Fires for all existing listeners.
	]]
	--[[
		*
		* Registers a listener added event.
		* Fires whenever a listener has a lifecycle event with the specified ID.
		*
		* Fires for all existing listeners.
	]]
	--[[
		*
		* Registers a listener added event.
	]]
	local function onListenerAdded(func, id)
		if id ~= nil then
			local _id = id
			local listenerAddedEvent = listenerAddedEvents[_id]
			if not listenerAddedEvent then
				local _exp = id
				listenerAddedEvent = Signal.new()
				local _listenerAddedEvent = listenerAddedEvent
				listenerAddedEvents[_exp] = _listenerAddedEvent
			end
			local _id_1 = id
			local _condition = lifecycleListeners[_id_1]
			if not _condition then
				local _id_2 = id
				_condition = decoratorListeners[_id_2]
			end
			local existingListeners = _condition
			if existingListeners then
				for listener in existingListeners do
					task.spawn(func, listener)
				end
			end
			return listenerAddedEvent:Connect(func)
		else
			for listener in listeners do
				task.spawn(func, listener)
			end
			return listenerAdded:Connect(func)
		end
	end
	_container.onListenerAdded = onListenerAdded
	--[[
		*
		* Registers a listener removed event.
		*
		* Fires whenever any listener is removed.
	]]
	--[[
		*
		* Registers a listener removed event.
		*
		* Fires whenever a listener has a decorator with the specified ID.
	]]
	--[[
		*
		* Registers a listener removed event.
		*
		* Fires whenever a listener has a lifecycle event with the specified ID.
	]]
	--[[
		*
		* Registers a listener removed event.
	]]
	local function onListenerRemoved(func, id)
		if id ~= nil then
			local _id = id
			local listenerRemovedEvent = listenerRemovedEvents[_id]
			if not listenerRemovedEvent then
				local _exp = id
				listenerRemovedEvent = Signal.new()
				local _listenerRemovedEvent = listenerRemovedEvent
				listenerRemovedEvents[_exp] = _listenerRemovedEvent
			end
			return listenerRemovedEvent:Connect(func)
		else
			return listenerRemoved:Connect(func)
		end
	end
	_container.onListenerRemoved = onListenerRemoved
	--[[
		*
		* Registers a class decorator.
	]]
	--[[
		*
		* Registers a method decorator.
	]]
	--[[
		*
		* Registers a property decorator.
	]]
	--[[
		*
		* Registers a decorator.
	]]
	local defineDecoratorMetadata
	local function createDecorator(_kind, func)
		return {
			func = function(descriptor, config)
				defineDecoratorMetadata(descriptor, config)
				func(descriptor, config)
			end,
		}
	end
	_container.createDecorator = createDecorator
	--[[
		*
		* Registers a metadata class decorator.
	]]
	--[[
		*
		* Registers a metadata method decorator.
	]]
	--[[
		*
		* Registers a metadata property decorator.
	]]
	--[[
		*
		* Registers a metadata decorator.
	]]
	local function createMetaDecorator(_kind)
		return {
			func = function(descriptor, config)
				defineDecoratorMetadata(descriptor, config)
			end,
		}
	end
	_container.createMetaDecorator = createMetaDecorator
	--[[
		*
		* Retrieves registered decorators.
	]]
	local function getDecorators(id)
		local _arg0 = id ~= nil
		assert(_arg0)
		local _decorators = Reflect.decorators
		local _id = id
		local decorators = _decorators[_id]
		if not decorators then
			return {}
		end
		local _arg0_1 = function(object)
			local decoratorConfig = Reflect.getOwnMetadata(object, "flamework:decorators." .. id)
			assert(decoratorConfig)
			return {
				object = object,
				arguments = decoratorConfig.arguments,
			}
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#decorators)
		for _k, _v in decorators do
			_newValue[_k] = _arg0_1(_v, _k - 1, decorators)
		end
		-- ▲ ReadonlyArray.map ▲
		return _newValue
	end
	_container.getDecorators = getDecorators
	--[[
		*
		* Creates a map of every property using the specified decorator.
	]]
	local getDecorator
	local function getPropertyDecorators(obj, id)
		local decorators = {}
		local _arg0 = id ~= nil
		assert(_arg0)
		for _, prop in Reflect.getProperties(obj) do
			local decorator = getDecorator(obj, prop, id)
			if decorator then
				decorators[prop] = decorator
			end
		end
		return decorators
	end
	_container.getPropertyDecorators = getPropertyDecorators
	--[[
		*
		* Retrieves a decorator from an object or its properties.
	]]
	function getDecorator(object, property, id)
		local decorator = Reflect.getMetadata(object, "flamework:decorators." .. tostring(id), property)
		if not decorator then
			return nil
		end
		return decorator
	end
	_container.getDecorator = getDecorator
	--[[
		*
		* Retrieves a singleton or instantiates one if it does not exist.
	]]
	local createDependency
	local function resolveSingleton(ctor)
		local _ctor = ctor
		local resolvedDependency = resolvedSingletons[_ctor]
		if resolvedDependency ~= nil then
			return resolvedDependency
		end
		local _ctor_1 = ctor
		if table.find(loadingList, _ctor_1) ~= nil then
			-- ▼ ReadonlyArray.join ▼
			local _result = table.create(#loadingList)
			for _k, _v in loadingList do
				_result[_k] = tostring(_v)
			end
			-- ▲ ReadonlyArray.join ▲
			error("Circular dependency detected " .. (table.concat(_result, " <=> ") .. (" <=> " .. tostring(ctor))))
		end
		local _ctor_2 = ctor
		table.insert(loadingList, _ctor_2)
		-- Flamework can resolve singletons at any arbitrary point,
		-- so we should fetch custom dependency resolution (added via decorator) through the Reflect api.
		local opts = Reflect.getOwnMetadata(ctor, "flamework:dependency_resolution")
		local dependency = createDependency(ctor, opts)
		local _ctor_3 = ctor
		resolvedSingletons[_ctor_3] = dependency
		loadingList[#loadingList] = nil
		addListener(dependency)
		return dependency
	end
	_container.resolveSingleton = resolveSingleton
	-- * @internal Used for bootstrapping
	local function getSingletons()
		return resolvedSingletons
	end
	_container.getSingletons = getSingletons
	--[[
		*
		* Modifies dependency resolution for a specific ID.
		*
		* If a function is passed, it will be called, passing the target constructor, every time that ID needs to be resolved.
		* Otherwise, the passed object is returned directly.
	]]
	local function registerDependency(dependency, id)
		local _arg0 = id ~= nil
		assert(_arg0)
		local _dependency = dependency
		if type(_dependency) == "function" then
			local _id = id
			local _dependency_1 = dependency
			dependencyResolution[_id] = _dependency_1
		else
			local _id = id
			local _arg1 = function()
				return dependency
			end
			dependencyResolution[_id] = _arg1
		end
	end
	_container.registerDependency = registerDependency
	--[[
		*
		* Instantiates this class using dependency injection.
	]]
	local createDeferredDependency
	function createDependency(ctor, options)
		if options == nil then
			options = {}
		end
		local _binding = createDeferredDependency(ctor, options)
		local obj = _binding[1]
		local construct = _binding[2]
		construct()
		return obj
	end
	_container.createDependency = createDependency
	--[[
		*
		* Creates an object for this class and returns a deferred constructor.
	]]
	local resolveDependency
	function createDeferredDependency(ctor, options)
		if options == nil then
			options = {}
		end
		local _binding = getDeferredConstructor(ctor)
		local obj = _binding[1]
		local construct = _binding[2]
		return { obj, function()
			local dependencies = Reflect.getMetadata(ctor, "flamework:parameters")
			local constructorDependencies = {}
			if dependencies then
				for index, dependencyId in pairs(dependencies) do
					constructorDependencies[index - 1 + 1] = resolveDependency(ctor, dependencyId, index - 1, options)
				end
			end
			construct(unpack(constructorDependencies))
		end }
	end
	_container.createDeferredDependency = createDeferredDependency
	--[[
		*
		* Dependency resolution logic.
		* @internal
	]]
	function resolveDependency(ctor, dependencyId, index, options)
		if options.handle ~= nil then
			local dependency = options.handle(dependencyId, index)
			if dependency ~= nil then
				return dependency
			end
		end
		local _dependencyId = dependencyId
		local resolution = dependencyResolution[_dependencyId]
		if resolution ~= nil then
			return resolution(ctor)
		end
		local _idToObj = Reflect.idToObj
		local _dependencyId_1 = dependencyId
		local dependencyCtor = _idToObj[_dependencyId_1]
		if dependencyCtor and isConstructor(dependencyCtor) then
			return resolveSingleton(dependencyCtor)
		end
		if string.sub(dependencyId, 1, 2) == "$p" then
			if string.sub(dependencyId, 1, 3) == "$ps" then
				return string.sub(dependencyId, 5)
			end
			if string.sub(dependencyId, 1, 3) == "$pn" then
				local _condition = tonumber(string.sub(dependencyId, 5))
				if _condition == nil then
					_condition = 0
				end
				return _condition
			end
			if options.handlePrimitive ~= nil then
				return options.handlePrimitive(dependencyId, index)
			end
			error("Unexpected primitive dependency '" .. (dependencyId .. ("' while constructing " .. tostring(ctor))))
		end
		error("Could not find constructor for " .. (dependencyId .. (" while constructing " .. tostring(ctor))))
	end
	_container.resolveDependency = resolveDependency
	--[[
		*
		* This function is able to utilize Flamework's user macros to generate and inspect types.
		* This function supports all values natively supported by Flamework's user macros.
		*
		* For example, if you want to retrieve the properties of an instance, you could write code like this:
		* ```ts
		* // Returns an array of all keys part of the union.
		* const basePartKeys = Modding.inspect<InstancePropertyNames<BasePart>[]>();
		* ```
		*
		* @metadata macro
	]]
	local function inspect(value)
		local _value = value
		assert(_value)
		return value
	end
	_container.inspect = inspect
	--[[
		*
		* @hidden
		* @deprecated
	]]
	local function macro(values, directValue)
		local _values = values
		if type(_values) == "string" then
			return {
				[values] = directValue,
			}
		end
		local result = {}
		for _, _binding in values do
			local name = _binding[1]
			local value = _binding[2]
			result[name] = value
		end
		return result
	end
	_container.macro = macro
	--[[
		*
		* This API allows you to use more complex queries, inspect types, generate arbitrary objects based on types, etc.
		*
		* @experimental This API is considered experimental and may change.
	]]
	--[[
		*
		* Hashes a string literal type (such as an event name) under Flamework's {@link Many `Many`} API.
		*
		* The second type argument, `C`, is for providing a context to the hashing which will generate new hashes
		* for strings which already have a hash under another context.
		*
		* @experimental This API is considered experimental and may change.
	]]
	--[[
		*
		* This is equivalent to {@link Hash `Hash`} except it will only hash strings when `obfuscation` is turned on.
		*
		* @experimental This API is considered experimental and may change.
	]]
	--[[
		*
		* Retrieves the labels from this tuple under Flamework's {@link Many `Many`} API.
		*
		* This can also be used to extract parameter names via `Parameters<T>`
		*
		* @experimental This API is considered experimental and may change.
	]]
	--[[
		*
		* Retrieves metadata about the specified type using Flamework's user macros.
	]]
	--[[
		*
		* Retrieves metadata about the callsite using Flamework's user macros.
	]]
	function defineDecoratorMetadata(descriptor, config)
		local propertyKey = if descriptor.isStatic then "static:" .. descriptor.property else descriptor.property
		Reflect.defineMetadata(descriptor.object, "flamework:decorators." .. descriptor.id, {
			arguments = config,
		}, propertyKey)
		local decoratorList = Reflect.getMetadata(descriptor.object, "flamework:decorators", propertyKey)
		if not decoratorList then
			local _fn = Reflect
			local _exp = descriptor.object
			decoratorList = {}
			_fn.defineMetadata(_exp, "flamework:decorators", decoratorList, propertyKey)
		end
		local _decoratorList = decoratorList
		local _id = descriptor.id
		table.insert(_decoratorList, _id)
	end
end
function isConstructor(obj)
	return obj.new ~= nil and obj.constructor ~= nil
end
function getDeferredConstructor(ctor)
	local obj = setmetatable({}, ctor)
	return { obj, function(...)
		local args = { ... }
		local result = obj:constructor(unpack(args))
		local _arg0 = result == nil or result == obj
		assert(_arg0, "Deferred constructors are not allowed to return values.")
	end }
end
return {
	Modding = Modding,
}
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="22">
                <Properties>
                  <string name="Name">reflect</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
--[[
	*
	* Reflection/metadata API
]]
local Reflect = {}
do
	local _container = Reflect
	-- object -> property -> key -> value
	local metadata = setmetatable({}, {
		__mode = "k",
	})
	_container.metadata = metadata
	local decorators = {}
	_container.decorators = decorators
	local idToObj = {}
	_container.idToObj = idToObj
	local objToId = {}
	_container.objToId = objToId
	local NO_PROP_MARKER = {}
	local function getObjMetadata(obj, prop, create)
		local _condition = prop
		if _condition == nil then
			_condition = NO_PROP_MARKER
		end
		local realProp = _condition
		if create then
			local _obj = obj
			local objMetadata = metadata[_obj]
			if not objMetadata then
				local _exp = obj
				objMetadata = {}
				local _objMetadata = objMetadata
				metadata[_exp] = _objMetadata
			end
			local propMetadata = objMetadata[realProp]
			if not propMetadata then
				local _objMetadata = objMetadata
				propMetadata = {}
				local _propMetadata = propMetadata
				_objMetadata[realProp] = _propMetadata
			end
			return propMetadata
		else
			local _obj = obj
			local _result = metadata[_obj]
			if _result ~= nil then
				_result = _result[realProp]
			end
			return _result
		end
	end
	local function getParentConstructor(obj)
		local metatable = getmetatable(obj)
		if metatable and type(metatable) == "table" then
			return rawget(metatable, "__index")
		end
	end
	--[[
		*
		* Apply metadata onto this object.
	]]
	local function defineMetadata(obj, key, value, property)
		-- 'identifier' is a special, unique ID across all metadata classes.
		if key == "identifier" then
			local _value = value
			local _arg0 = type(_value) == "string"
			assert(_arg0, "identifier must be a string.")
			local _obj = obj
			local _arg0_1 = not (objToId[_obj] ~= nil)
			assert(_arg0_1, "obj is already registered.")
			local _value_1 = value
			local _arg0_2 = not (idToObj[_value_1] ~= nil)
			assert(_arg0_2, "id is already registered.")
			local _obj_1 = obj
			local _value_2 = value
			objToId[_obj_1] = _value_2
			local _value_3 = value
			local _obj_2 = obj
			idToObj[_value_3] = _obj_2
		end
		local metadata = getObjMetadata(obj, property, true)
		local _key = key
		local _value = value
		metadata[_key] = _value
	end
	_container.defineMetadata = defineMetadata
	--[[
		*
		* Apply metadata in batch onto this object.
	]]
	local function defineMetadataBatch(obj, list, property)
		local metadata = getObjMetadata(obj, property, true)
		for key, value in pairs(list) do
			metadata[key] = value
		end
	end
	_container.defineMetadataBatch = defineMetadataBatch
	--[[
		*
		* Delete metadata from this object.
	]]
	local function deleteMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			local _key = key
			_result[_key] = nil
		end
	end
	_container.deleteMetadata = deleteMetadata
	--[[
		*
		* Get metadata from this object.
		* Type parameter is an assertion.
	]]
	local function getOwnMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			local _key = key
			_result = _result[_key]
		end
		return _result
	end
	_container.getOwnMetadata = getOwnMetadata
	--[[
		*
		* Check if this object has the specified metadata key.
	]]
	local function hasOwnMetadata(obj, key, property)
		local metadata = getObjMetadata(obj, property)
		local _result = metadata
		if _result ~= nil then
			local _key = key
			_result = _result[_key] ~= nil
		end
		local _condition = _result
		if _condition == nil then
			_condition = false
		end
		return _condition
	end
	_container.hasOwnMetadata = hasOwnMetadata
	--[[
		*
		* Retrieve all metadata keys for this object.
	]]
	local function getOwnMetadataKeys(obj, property)
		local metadata = getObjMetadata(obj, property)
		local keys = {}
		local _result = metadata
		if _result ~= nil then
			local _arg0 = function(_, key)
				local _key = key
				table.insert(keys, _key)
				return #keys
			end
			for _k, _v in _result do
				_arg0(_v, _k, _result)
			end
		end
		return keys
	end
	_container.getOwnMetadataKeys = getOwnMetadataKeys
	--[[
		*
		* Retrieves all properties (that contain metadata) on this object.
	]]
	local function getOwnProperties(obj)
		local _obj = obj
		local properties = metadata[_obj]
		if not properties then
			return {}
		end
		local keys = {}
		for key in properties do
			if key ~= NO_PROP_MARKER then
				table.insert(keys, key)
			end
		end
		return keys
	end
	_container.getOwnProperties = getOwnProperties
	--[[
		*
		* Retrieve all values for the specified key from the object and its parents.
		* Type parameter is an assertion.
	]]
	local function getMetadatas(obj, key, property)
		local values = {}
		local value = getOwnMetadata(obj, key, property)
		if value ~= nil then
			table.insert(values, value)
		end
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getMetadatas(parent, key, property)
			local _arg0 = function(value)
				local _value = value
				table.insert(values, _value)
				return #values
			end
			for _k, _v in _exp do
				_arg0(_v, _k - 1, _exp)
			end
		end
		return values
	end
	_container.getMetadatas = getMetadatas
	--[[
		*
		* Get metadata from this object or its parents.
		* Type parameter is an assertion.
	]]
	local function getMetadata(obj, key, property)
		local value = getOwnMetadata(obj, key, property)
		if value ~= nil then
			return value
		end
		local parent = getParentConstructor(obj)
		if parent then
			return getMetadata(parent, key, property)
		end
	end
	_container.getMetadata = getMetadata
	--[[
		*
		* Check if this object or any of its parents has the specified metadata key.
	]]
	local function hasMetadata(obj, key, property)
		local value = hasOwnMetadata(obj, key, property)
		if value then
			return value
		end
		local parent = getParentConstructor(obj)
		if parent then
			return hasMetadata(parent, key, property)
		end
		return false
	end
	_container.hasMetadata = hasMetadata
	--[[
		*
		* Retrieve all metadata keys for this object and its parents.
	]]
	local function getMetadataKeys(obj, property)
		local _set = {}
		for _, _v in getOwnMetadataKeys(obj, property) do
			_set[_v] = true
		end
		local keys = _set
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getMetadataKeys(parent, property)
			local _arg0 = function(key)
				local _key = key
				keys[_key] = true
				return keys
			end
			for _k, _v in _exp do
				_arg0(_v, _k - 1, _exp)
			end
		end
		local _array = {}
		local _length = #_array
		for _v in keys do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	_container.getMetadataKeys = getMetadataKeys
	--[[
		*
		* Retrieves all properties (that contain metadata) on this object and its parents.
	]]
	local function getProperties(obj)
		local _set = {}
		for _, _v in getOwnProperties(obj) do
			_set[_v] = true
		end
		local keys = _set
		local parent = getParentConstructor(obj)
		if parent then
			local _exp = getProperties(parent)
			local _arg0 = function(key)
				local _key = key
				keys[_key] = true
				return keys
			end
			for _k, _v in _exp do
				_arg0(_v, _k - 1, _exp)
			end
		end
		local _array = {}
		local _length = #_array
		for _v in keys do
			_length += 1
			_array[_length] = _v
		end
		return _array
	end
	_container.getProperties = getProperties
	-- * @hidden
	local function decorate(object, id, rawDecoration, args, property, isStatic)
		if isStatic == nil then
			isStatic = false
		end
		local decoration = rawDecoration
		local descriptor = {
			id = id,
			isStatic = isStatic,
			object = object,
			property = property,
		}
		if property == nil then
			local _id = id
			local decoratedObjects = decorators[_id]
			if not decoratedObjects then
				local _exp = id
				decoratedObjects = {}
				local _decoratedObjects = decoratedObjects
				decorators[_exp] = _decoratedObjects
			end
			local _decoratedObjects = decoratedObjects
			local _object = object
			table.insert(_decoratedObjects, _object)
		end
		decoration.func(descriptor, args)
	end
	_container.decorate = decorate
end
return {
	Reflect = Reflect,
}
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="23">
            <Properties>
              <string name="Name">networking</string>
            </Properties>
            <Item class="ModuleScript" referent="24">
              <Properties>
                <string name="Name">out</string>
                <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local NetworkingSkip = TS.import(script, script, "middleware", "skip").Skip
local registerHandler = TS.import(script, script, "handlers").registerNetworkHandler
local NetworkingFunctionError = TS.import(script, script, "functions", "errors").NetworkingFunctionError
local Networking = {}
do
	local _container = Networking
	--[[
		*
		* Creates a new event based off the supplied types.
		* @param serverMiddleware Middleware for server events
		* @param clientMiddleware Middleware for client events
	]]
	--[[
		*
		* Creates a new function event based off the supplied types.
		* @param serverMiddleware Middleware for server events
		* @param clientMiddleware Middleware for client events
	]]
	--[[
		*
		* Connects to a global network event.
	]]
	local registerNetworkHandler = registerHandler
	_container.registerNetworkHandler = registerNetworkHandler
	--[[
		*
		* Stops networking function middleware.
	]]
	local Skip = NetworkingSkip
	_container.Skip = Skip
	--[[
		*
		* A function that generates middleware.
		* @hidden
		* @deprecated Use {@link EventMiddleware} or {@link FunctionMiddleware}
	]]
	--[[
		*
		* A function that generates an event middleware.
	]]
	--[[
		*
		* A function that generates an event middleware.
	]]
end
return {
	Networking = Networking,
	NetworkingFunctionError = NetworkingFunctionError,
}
]]></string>
              </Properties>
              <Item class="Folder" referent="25">
                <Properties>
                  <string name="Name">events</string>
                </Properties>
                <Item class="ModuleScript" referent="26">
                  <Properties>
                    <string name="Name">createClientHandler</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local fireNetworkHandler = TS.import(script, script.Parent.Parent, "handlers").fireNetworkHandler
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local createClientMethod
local function createClientHandler(remotes, networkInfos, serverEvents, clientEvents, config, middlewareFactoryList)
	local handler = {}
	local bindables = {}
	local processors = {}
	local isSetup = {}
	for name in pairs(clientEvents) do
		local bindable = Instance.new("BindableEvent")
		bindables[name] = bindable
	end
	local setupRemote = function(name)
		local _name = name
		if isSetup[_name] ~= nil then
			return nil
		end
		local _name_1 = name
		isSetup[_name_1] = true
		local _remotes = remotes
		local _name_2 = name
		local remote = _remotes[_name_2]
		local _networkInfos = networkInfos
		local _name_3 = name
		local networkInfo = _networkInfos[_name_3]
		local _name_4 = name
		local middlewareProcessor = processors[_name_4]
		remote.OnClientEvent:Connect(function(...)
			local args = { ... }
			local guards = clientEvents[name]
			if not guards then
				return nil
			end
			if not config.disableClientGuards then
				local paramGuards = guards[1]
				local restGuard = guards[2]
				do
					local i = 0
					local _shouldIncrement = false
					while true do
						if _shouldIncrement then
							i += 1
						else
							_shouldIncrement = true
						end
						if not (i < #args) then
							break
						end
						local guard = paramGuards[i + 1] or restGuard
						if guard and not guard(args[i + 1]) then
							fireNetworkHandler("onBadRequest", Players.LocalPlayer, networkInfo, i)
							return nil
						end
					end
				end
			end
			middlewareProcessor(nil, unpack(args))
		end)
	end
	for name, remote in remotes do
		local networkInfo = networkInfos[name]
		local _result = middlewareFactoryList
		if _result ~= nil then
			_result = _result[name]
		end
		local middlewareProcessor = createMiddlewareProcessor(_result, networkInfo, function(_, ...)
			local args = { ... }
			local _result_1 = bindables[name]
			if _result_1 ~= nil then
				_result_1 = _result_1:Fire(unpack(args))
			end
			return _result_1
		end)
		processors[name] = middlewareProcessor
		local _exp = function()
			return setupRemote(name)
		end
		local _result_1 = clientEvents[name]
		if _result_1 ~= nil then
			_result_1 = #_result_1
		end
		local _condition = _result_1
		if _condition == nil then
			_condition = 0
		end
		handler[name] = createClientMethod(_exp, remote, _condition, bindables[name], middlewareProcessor)
	end
	return handler
end
function createClientMethod(connect, remote, paramCount, bindable, process)
	local method = {
		fire = function(self, ...)
			local args = { ... }
			remote:FireServer(unpack(args))
		end,
		connect = function(self, callback, customGuards)
			local _bindable = bindable
			local _arg1 = "Event " .. (remote.Name .. " is not registered as a receiver.")
			assert(_bindable, _arg1)
			task.defer(connect)
			return bindable.Event:Connect(function(...)
				local args = { ... }
				if customGuards then
					do
						local i = 0
						local _shouldIncrement = false
						while true do
							if _shouldIncrement then
								i += 1
							else
								_shouldIncrement = true
							end
							if not (i < paramCount) then
								break
							end
							local guard = customGuards[i + 1]
							if guard ~= nil and not guard(args[i + 1]) then
								return nil
							end
						end
					end
				end
				return callback(unpack(args))
			end)
		end,
		predict = function(self, ...)
			local args = { ... }
			local _process = process
			local _arg1 = "Event " .. (remote.Name .. " does not have a middleware processor.")
			assert(_process, _arg1)
			process(nil, unpack(args))
		end,
	}
	setmetatable(method, {
		__call = function(method, ...)
			local args = { ... }
			method:fire(unpack(args))
		end,
	})
	return method
end
return {
	createClientHandler = createClientHandler,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="27">
                  <Properties>
                    <string name="Name">createNetworkingEvent</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Object = TS.import(script, TS.getModule(script, "@rbxts", "object-utils"))
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local populateInstanceMap = TS.import(script, script.Parent.Parent, "util", "populateInstanceMap").populateInstanceMap
local createClientHandler = TS.import(script, script.Parent, "createClientHandler").createClientHandler
local createServerHandler = TS.import(script, script.Parent, "createServerHandler").createServerHandler
local function getDefaultConfiguration(config)
	local _object = {}
	local _left = "disableClientGuards"
	local _condition = config.disableClientGuards
	if _condition == nil then
		_condition = false
	end
	_object[_left] = _condition
	local _left_1 = "disableServerGuards"
	local _condition_1 = config.disableServerGuards
	if _condition_1 == nil then
		_condition_1 = false
	end
	_object[_left_1] = _condition_1
	return _object
end
local function createNetworkingEvent(globalName, serverEvents, clientEvents, serverMiddleware, clientMiddleware, partialConfig)
	if partialConfig == nil then
		partialConfig = {}
	end
	local config = getDefaultConfiguration(partialConfig)
	local networkInfos = {}
	local remotes = {}
	populateInstanceMap("RemoteEvent", "events-" .. globalName, Object.keys(serverEvents), remotes)
	populateInstanceMap("RemoteEvent", "events-" .. globalName, Object.keys(clientEvents), remotes)
	for name in remotes do
		local _arg1 = {
			eventType = "Event",
			globalName = globalName,
			name = name,
		}
		networkInfos[name] = _arg1
	end
	if RunService:IsServer() then
		return {
			server = createServerHandler(remotes, networkInfos, serverEvents, clientEvents, config, serverMiddleware),
			client = nil,
		}
	else
		return {
			server = nil,
			client = createClientHandler(remotes, networkInfos, serverEvents, clientEvents, config, clientMiddleware),
		}
	end
end
return {
	createNetworkingEvent = createNetworkingEvent,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="28">
                  <Properties>
                    <string name="Name">createServerHandler</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local fireNetworkHandler = TS.import(script, script.Parent.Parent, "handlers").fireNetworkHandler
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local createServerMethod
local function createServerHandler(remotes, networkInfos, serverEvents, clientEvents, config, middlewareFactoryList)
	local handler = {}
	local bindables = {}
	local processors = {}
	local isSetup = {}
	for name in pairs(serverEvents) do
		local bindable = Instance.new("BindableEvent")
		bindables[name] = bindable
	end
	local setupRemote = function(name)
		local _name = name
		if isSetup[_name] ~= nil then
			return nil
		end
		local _name_1 = name
		isSetup[_name_1] = true
		local _remotes = remotes
		local _name_2 = name
		local remote = _remotes[_name_2]
		local _networkInfos = networkInfos
		local _name_3 = name
		local networkInfo = _networkInfos[_name_3]
		local _name_4 = name
		local middlewareProcessor = processors[_name_4]
		remote.OnServerEvent:Connect(function(player, ...)
			local args = { ... }
			local guards = serverEvents[name]
			if not guards then
				return nil
			end
			if not config.disableServerGuards then
				local paramGuards = guards[1]
				local restGuard = guards[2]
				do
					local i = 0
					local _shouldIncrement = false
					while true do
						if _shouldIncrement then
							i += 1
						else
							_shouldIncrement = true
						end
						if not (i < #args) then
							break
						end
						local guard = paramGuards[i + 1] or restGuard
						if guard and not guard(args[i + 1]) then
							fireNetworkHandler("onBadRequest", player, networkInfo, i)
							return nil
						end
					end
				end
			end
			middlewareProcessor(player, unpack(args))
		end)
	end
	for name, remote in remotes do
		local networkInfo = networkInfos[name]
		local _result = middlewareFactoryList
		if _result ~= nil then
			_result = _result[name]
		end
		local middlewareProcessor = createMiddlewareProcessor(_result, networkInfo, function(player, ...)
			local args = { ... }
			local _result_1 = bindables[name]
			if _result_1 ~= nil then
				_result_1 = _result_1:Fire(player, unpack(args))
			end
			return _result_1
		end)
		processors[name] = middlewareProcessor
		local _exp = function()
			return setupRemote(name)
		end
		local _result_1 = serverEvents[name]
		if _result_1 ~= nil then
			_result_1 = #_result_1
		end
		local _condition = _result_1
		if _condition == nil then
			_condition = 0
		end
		handler[name] = createServerMethod(_exp, remote, _condition, bindables[name], middlewareProcessor)
	end
	return handler
end
function createServerMethod(connect, remote, paramCount, bindable, process)
	local method = {
		fire = function(self, players, ...)
			local args = { ... }
			local _players = players
			if typeof(_players) == "Instance" then
				remote:FireClient(players, unpack(args))
			else
				for _, player in players do
					remote:FireClient(player, unpack(args))
				end
			end
		end,
		broadcast = function(self, ...)
			local args = { ... }
			remote:FireAllClients(unpack(args))
		end,
		except = function(self, players, ...)
			local args = { ... }
			local _players = players
			if typeof(_players) == "Instance" then
				players = { players }
			end
			for _, player in Players:GetPlayers() do
				if not (table.find(players, player) ~= nil) then
					self:fire(player, unpack(args))
				end
			end
		end,
		connect = function(self, callback, customGuards)
			local _bindable = bindable
			local _arg1 = "Event " .. (remote.Name .. " is not registered as a receiver.")
			assert(_bindable, _arg1)
			task.defer(connect)
			return bindable.Event:Connect(function(player, ...)
				local args = { ... }
				if customGuards then
					do
						local i = 0
						local _shouldIncrement = false
						while true do
							if _shouldIncrement then
								i += 1
							else
								_shouldIncrement = true
							end
							if not (i < paramCount) then
								break
							end
							local guard = customGuards[i + 1]
							if guard ~= nil and not guard(args[i + 1]) then
								return nil
							end
						end
					end
				end
				return callback(player, unpack(args))
			end)
		end,
		predict = function(self, player, ...)
			local args = { ... }
			local _process = process
			local _arg1 = "Event " .. (remote.Name .. " does not have a middleware processor.")
			assert(_process, _arg1)
			process(player, unpack(args))
		end,
	}
	setmetatable(method, {
		__call = function(method, player, ...)
			local args = { ... }
			method:fire(player, unpack(args))
		end,
	})
	return method
end
return {
	createServerHandler = createServerHandler,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="29">
                <Properties>
                  <string name="Name">functions</string>
                </Properties>
                <Item class="ModuleScript" referent="30">
                  <Properties>
                    <string name="Name">createClientHandler</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local _errors = TS.import(script, script.Parent, "errors")
local getFunctionError = _errors.getFunctionError
local NetworkingFunctionError = _errors.NetworkingFunctionError
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local Skip = TS.import(script, script.Parent.Parent, "middleware", "skip").Skip
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local fireNetworkHandler = TS.import(script, script.Parent.Parent, "handlers").fireNetworkHandler
local createClientMethod, getProcessResult
local function createClientHandler(serverRemotes, clientRemotes, networkInfos, serverEvents, clientEvents, config, middlewareFactoryList)
	local handler = {}
	local processors = {}
	local requestInfo = {
		nextId = 0,
		requests = {},
	}
	local function createMethod(name, networkInfo, remote)
		if handler[name] ~= nil then
			return nil
		end
		local _exp = (serverEvents[name] or clientEvents[name])[2]
		local _result = middlewareFactoryList
		if _result ~= nil then
			_result = _result[name]
		end
		local _condition = _result
		if _condition == nil then
			_condition = {}
		end
		handler[name] = createClientMethod(_exp, _condition, processors, networkInfo, requestInfo, name, remote, config)
	end
	for alias, remote in serverRemotes do
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnClientEvent:Connect(function(id, processResult, result)
			if not t.number(id) then
				return nil
			end
			local _requests = requestInfo.requests
			local _id = id
			local request = _requests[_id]
			local _requests_1 = requestInfo.requests
			local _id_1 = id
			_requests_1[_id_1] = nil
			if request then
				request(result, getFunctionError(processResult))
			end
		end)
	end
	for alias, remote in clientRemotes do
		-- invoke callback
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnClientEvent:Connect(function(id, ...)
			local args = { ... }
			local guards = clientEvents[name]
			if not guards then
				return nil
			end
			if not config.disableClientGuards then
				local paramGuards = guards[1][1]
				local restGuard = guards[1][2]
				do
					local i = 0
					local _shouldIncrement = false
					while true do
						if _shouldIncrement then
							i += 1
						else
							_shouldIncrement = true
						end
						if not (i < #args) then
							break
						end
						local guard = paramGuards[i + 1] or restGuard
						if guard and not guard(args[i + 1]) then
							fireNetworkHandler("onBadRequest", Players.LocalPlayer, networkInfo, i)
							return remote:FireServer(id, NetworkingFunctionError.BadRequest)
						end
					end
				end
			end
			local processor = processors[name]
			if processor then
				local result = processor(nil, unpack(args))
				local _arg0 = function(value)
					return remote:FireServer(id, getProcessResult(value), value)
				end
				result:andThen(_arg0):catch(function(reason)
					warn("Failed to process request to " .. name)
					warn(reason)
					remote:FireServer(id, false)
				end)
			else
				remote:FireServer(id, false)
			end
		end)
	end
	return handler
end
local timeoutPromise
function createClientMethod(guard, middleware, processors, networkInfo, requestInfo, name, remote, config)
	local method = {
		invoke = function(self, ...)
			local args = { ... }
			return self:invokeWithTimeout(config.defaultClientTimeout, unpack(args))
		end,
		invokeWithTimeout = function(self, timeout, ...)
			local args = { ... }
			return TS.Promise.race({ timeoutPromise(timeout, NetworkingFunctionError.Timeout), TS.Promise.new(function(resolve, reject, onCancel)
				local _original = requestInfo.nextId
				requestInfo.nextId += 1
				local id = _original
				local _requests = requestInfo.requests
				local _arg1 = function(value, rejection)
					if rejection then
						return reject(rejection)
					end
					if not config.disableClientGuards and not guard(value) then
						fireNetworkHandler("onBadResponse", Players.LocalPlayer, networkInfo)
						return reject(NetworkingFunctionError.InvalidResult)
					end
					resolve(value)
				end
				_requests[id] = _arg1
				onCancel(function()
					requestInfo.requests[id] = nil
				end)
				remote:FireServer(id, unpack(args))
			end) })
		end,
		setCallback = function(self, callback)
			local _processors = processors
			local _name = name
			if _processors[_name] ~= nil then
				warn("Function.setCallback was called multiple times for " .. name)
			end
			local processor = createMiddlewareProcessor(middleware, networkInfo, function(_, ...)
				local args = { ... }
				return callback(unpack(args))
			end)
			local _processors_1 = processors
			local _name_1 = name
			_processors_1[_name_1] = processor
		end,
		predict = function(self, ...)
			local args = { ... }
			return TS.Promise.new(function(resolve, reject)
				local _processors = processors
				local _name = name
				local processor = _processors[_name]
				if not processor then
					return reject(NetworkingFunctionError.Unprocessed)
				end
				resolve(processor(nil, unpack(args)))
			end)
		end,
	}
	setmetatable(method, {
		__call = function(method, ...)
			local args = { ... }
			return method:invoke(unpack(args))
		end,
	})
	return method
end
function timeoutPromise(timeout, rejectValue)
	local _exp = TS.Promise.delay(timeout)
	local _arg0 = function()
		return TS.Promise.reject(rejectValue)
	end
	return _exp:andThen(_arg0)
end
function getProcessResult(value)
	return if value == Skip then NetworkingFunctionError.Cancelled else true
end
return {
	createClientHandler = createClientHandler,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="31">
                  <Properties>
                    <string name="Name">createNetworkingFunction</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Object = TS.import(script, TS.getModule(script, "@rbxts", "object-utils"))
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local populateInstanceMap = TS.import(script, script.Parent.Parent, "util", "populateInstanceMap").populateInstanceMap
local createClientHandler = TS.import(script, script.Parent, "createClientHandler").createClientHandler
local createServerHandler = TS.import(script, script.Parent, "createServerHandler").createServerHandler
local function getDefaultConfiguration(config)
	local _object = {}
	local _left = "disableClientGuards"
	local _condition = config.disableClientGuards
	if _condition == nil then
		_condition = false
	end
	_object[_left] = _condition
	local _left_1 = "disableServerGuards"
	local _condition_1 = config.disableServerGuards
	if _condition_1 == nil then
		_condition_1 = false
	end
	_object[_left_1] = _condition_1
	local _left_2 = "defaultClientTimeout"
	local _condition_2 = config.defaultClientTimeout
	if _condition_2 == nil then
		_condition_2 = 30
	end
	_object[_left_2] = _condition_2
	local _left_3 = "defaultServerTimeout"
	local _condition_3 = config.defaultServerTimeout
	if _condition_3 == nil then
		_condition_3 = 10
	end
	_object[_left_3] = _condition_3
	return _object
end
local function createNetworkingFunction(globalName, serverEvents, clientEvents, serverMiddleware, clientMiddleware, partialConfig)
	if partialConfig == nil then
		partialConfig = {}
	end
	local config = getDefaultConfiguration(partialConfig)
	local networkInfos = {}
	local serverRemotes = {}
	local clientRemotes = {}
	local _exp = Object.keys(serverEvents)
	local _arg0 = function(x)
		return "s:" .. tostring(x)
	end
	-- ▼ ReadonlyArray.map ▼
	local _newValue = table.create(#_exp)
	for _k, _v in _exp do
		_newValue[_k] = _arg0(_v, _k - 1, _exp)
	end
	-- ▲ ReadonlyArray.map ▲
	local serverNames = _newValue
	local _exp_1 = Object.keys(clientEvents)
	local _arg0_1 = function(x)
		return "c:" .. tostring(x)
	end
	-- ▼ ReadonlyArray.map ▼
	local _newValue_1 = table.create(#_exp_1)
	for _k, _v in _exp_1 do
		_newValue_1[_k] = _arg0_1(_v, _k - 1, _exp_1)
	end
	-- ▲ ReadonlyArray.map ▲
	local clientNames = _newValue_1
	populateInstanceMap("RemoteEvent", "functions-" .. globalName, serverNames, serverRemotes)
	populateInstanceMap("RemoteEvent", "functions-" .. globalName, clientNames, clientRemotes)
	for alias in serverRemotes do
		local name = string.sub(alias, 3)
		local _arg1 = {
			eventType = "Function",
			globalName = globalName,
			name = name,
		}
		networkInfos[name] = _arg1
	end
	for alias in clientRemotes do
		local name = string.sub(alias, 3)
		local _arg1 = {
			eventType = "Function",
			globalName = globalName,
			name = name,
		}
		networkInfos[name] = _arg1
	end
	if RunService:IsServer() then
		return {
			server = createServerHandler(serverRemotes, clientRemotes, networkInfos, serverEvents, clientEvents, config, serverMiddleware),
			client = nil,
		}
	else
		return {
			server = nil,
			client = createClientHandler(serverRemotes, clientRemotes, networkInfos, serverEvents, clientEvents, config, clientMiddleware),
		}
	end
end
return {
	createNetworkingFunction = createNetworkingFunction,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="32">
                  <Properties>
                    <string name="Name">createServerHandler</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local _errors = TS.import(script, script.Parent, "errors")
local getFunctionError = _errors.getFunctionError
local NetworkingFunctionError = _errors.NetworkingFunctionError
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local Skip = TS.import(script, script.Parent.Parent, "middleware", "skip").Skip
local fireNetworkHandler = TS.import(script, script.Parent.Parent, "handlers").fireNetworkHandler
local createServerMethod, getRequestInfo, getProcessResult
local function createServerHandler(serverRemotes, clientRemotes, networkInfos, serverEvents, clientEvents, config, middlewareFactoryList)
	local handler = {}
	local processors = {}
	local players = {}
	local function createMethod(name, networkInfo, remote)
		if handler[name] ~= nil then
			return nil
		end
		local _exp = (serverEvents[name] or clientEvents[name])[2]
		local _result = middlewareFactoryList
		if _result ~= nil then
			_result = _result[name]
		end
		local _condition = _result
		if _condition == nil then
			_condition = {}
		end
		handler[name] = createServerMethod(_exp, _condition, processors, networkInfo, players, name, remote, config)
	end
	for alias, remote in clientRemotes do
		-- create server method
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnServerEvent:Connect(function(player, id, processResult, result)
			if not t.number(id) then
				return nil
			end
			local requestInfo = getRequestInfo(player, players)
			local _requests = requestInfo.requests
			local _id = id
			local request = _requests[_id]
			local _requests_1 = requestInfo.requests
			local _id_1 = id
			_requests_1[_id_1] = nil
			if request then
				request(result, getFunctionError(processResult))
			end
		end)
	end
	for alias, remote in serverRemotes do
		-- invoke callback
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnServerEvent:Connect(function(player, id, ...)
			local args = { ... }
			local guards = serverEvents[name]
			if not guards then
				return nil
			end
			if not config.disableServerGuards then
				local paramGuards = guards[1][1]
				local restGuard = guards[1][2]
				do
					local i = 0
					local _shouldIncrement = false
					while true do
						if _shouldIncrement then
							i += 1
						else
							_shouldIncrement = true
						end
						if not (i < #args) then
							break
						end
						local guard = paramGuards[i + 1] or restGuard
						if guard and not guard(args[i + 1]) then
							fireNetworkHandler("onBadRequest", player, networkInfo, i)
							return remote:FireClient(player, id, NetworkingFunctionError.BadRequest)
						end
					end
				end
			end
			local processor = processors[name]
			if processor then
				local result = processor(player, unpack(args))
				local _arg0 = function(value)
					return remote:FireClient(player, id, getProcessResult(value), value)
				end
				result:andThen(_arg0):catch(function(reason)
					warn("Failed to process request to " .. name)
					warn(reason)
					remote:FireClient(player, id, false)
				end)
			else
				remote:FireClient(player, id, false)
			end
		end)
	end
	Players.PlayerRemoving:Connect(function(player)
		local _player = player
		players[_player] = nil
	end)
	return handler
end
local timeoutPromise
function createServerMethod(guard, middleware, processors, networkInfo, players, name, remote, config)
	local method = {
		invoke = function(self, player, ...)
			local args = { ... }
			return self:invokeWithTimeout(player, config.defaultServerTimeout, unpack(args))
		end,
		invokeWithTimeout = function(self, player, timeout, ...)
			local args = { ... }
			return TS.Promise.race({ timeoutPromise(timeout, NetworkingFunctionError.Timeout), TS.Promise.new(function(resolve, reject, onCancel)
				local requestInfo = getRequestInfo(player, players)
				local _original = requestInfo.nextId
				requestInfo.nextId += 1
				local id = _original
				local _requests = requestInfo.requests
				local _arg1 = function(value, rejection)
					if rejection then
						return reject(rejection)
					end
					if not config.disableServerGuards and not guard(value) then
						fireNetworkHandler("onBadResponse", player, networkInfo)
						return reject(NetworkingFunctionError.InvalidResult)
					end
					resolve(value)
				end
				_requests[id] = _arg1
				onCancel(function()
					requestInfo.requests[id] = nil
				end)
				remote:FireClient(player, id, unpack(args))
			end) })
		end,
		setCallback = function(self, callback)
			local _processors = processors
			local _name = name
			if _processors[_name] ~= nil then
				warn("Function.setCallback was called multiple times for " .. name)
			end
			local processor = createMiddlewareProcessor(middleware, networkInfo, callback)
			local _processors_1 = processors
			local _name_1 = name
			_processors_1[_name_1] = processor
		end,
		predict = function(self, player, ...)
			local args = { ... }
			return TS.Promise.new(function(resolve, reject)
				local _processors = processors
				local _name = name
				local processor = _processors[_name]
				if not processor then
					return reject(NetworkingFunctionError.Unprocessed)
				end
				resolve(processor(player, unpack(args)))
			end)
		end,
	}
	setmetatable(method, {
		__call = function(method, player, ...)
			local args = { ... }
			return method:invoke(player, unpack(args))
		end,
	})
	return method
end
function getRequestInfo(player, map)
	local _map = map
	local _player = player
	local requestInfo = _map[_player]
	if requestInfo then
		return requestInfo
	end
	requestInfo = {
		nextId = 0,
		requests = {},
	}
	local _map_1 = map
	local _player_1 = player
	local _requestInfo = requestInfo
	_map_1[_player_1] = _requestInfo
	return requestInfo
end
function timeoutPromise(timeout, rejectValue)
	local _exp = TS.Promise.delay(timeout)
	local _arg0 = function()
		return TS.Promise.reject(rejectValue)
	end
	return _exp:andThen(_arg0)
end
function getProcessResult(value)
	return if value == Skip then NetworkingFunctionError.Cancelled else true
end
return {
	createServerHandler = createServerHandler,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="33">
                  <Properties>
                    <string name="Name">errors</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local isNetworkingFunctionError = t.literal("Timeout", "Cancelled", "BadRequest", "Unprocessed", "InvalidResult")
local NetworkingFunctionError
do
	local _inverse = {}
	NetworkingFunctionError = setmetatable({}, {
		__index = _inverse,
	})
	NetworkingFunctionError.Timeout = "Timeout"
	_inverse.Timeout = "Timeout"
	NetworkingFunctionError.Cancelled = "Cancelled"
	_inverse.Cancelled = "Cancelled"
	NetworkingFunctionError.BadRequest = "BadRequest"
	_inverse.BadRequest = "BadRequest"
	NetworkingFunctionError.Unprocessed = "Unprocessed"
	_inverse.Unprocessed = "Unprocessed"
	NetworkingFunctionError.InvalidResult = "InvalidResult"
	_inverse.InvalidResult = "InvalidResult"
end
local function getFunctionError(value)
	local _value = value
	if type(_value) == "boolean" then
		return if value == false then NetworkingFunctionError.Unprocessed else nil
	elseif isNetworkingFunctionError(value) then
		return value
	end
end
return {
	getFunctionError = getFunctionError,
	isNetworkingFunctionError = isNetworkingFunctionError,
	NetworkingFunctionError = NetworkingFunctionError,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="34">
                <Properties>
                  <string name="Name">handlers</string>
                  <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Signal = TS.import(script, TS.getModule(script, "@rbxts", "signal"))
local NetworkEvents = {
	onBadRequest = Signal.new(),
	onBadResponse = Signal.new(),
}
local function registerNetworkHandler(event, callback)
	return NetworkEvents[event]:Connect(callback)
end
local function fireNetworkHandler(event, ...)
	local args = { ... }
	(NetworkEvents[event]):Fire(unpack(args))
end
return {
	registerNetworkHandler = registerNetworkHandler,
	fireNetworkHandler = fireNetworkHandler,
}
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="35">
                <Properties>
                  <string name="Name">middleware</string>
                </Properties>
                <Item class="ModuleScript" referent="36">
                  <Properties>
                    <string name="Name">createMiddlewareProcessor</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local function createMiddlewareProcessor(middlewareFactories, networkInfo, finalize)
	local middleware = {}
	if not middlewareFactories or #middlewareFactories == 0 then
		middleware[1] = finalize
	else
		do
			local i = #middlewareFactories - 1
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i -= 1
				else
					_shouldIncrement = true
				end
				if not (i >= 0) then
					break
				end
				local factory = middlewareFactories[i + 1]
				local processNext = middleware[i + 1 + 1] or finalize
				middleware[i + 1] = factory(TS.async(function(player, ...)
					local args = { ... }
					return processNext(player, unpack(args))
				end), networkInfo)
			end
		end
	end
	return TS.async(function(player, ...)
		local args = { ... }
		return middleware[1](player, unpack(args))
	end)
end
return {
	createMiddlewareProcessor = createMiddlewareProcessor,
}
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="37">
                  <Properties>
                    <string name="Name">skip</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local Skip = {
	__index = function()
		return nil
	end,
	__newindex = function()
		return nil
	end,
	__tostring = function()
		return "Networking.Skip"
	end,
}
setmetatable(Skip, Skip)
return {
	Skip = Skip,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="38">
                <Properties>
                  <string name="Name">util</string>
                </Properties>
                <Item class="ModuleScript" referent="39">
                  <Properties>
                    <string name="Name">populateInstanceMap</string>
                    <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local function populateInstanceMap(className, globalName, names, map)
	if not RunService:IsRunning() then
		for _, name in names do
			local instance = Instance.new(className)
			instance.Name = name
			map[name] = instance
		end
		return nil
	end
	local remotes = if RunService:IsServer() then ReplicatedStorage:FindFirstChild(globalName) else ReplicatedStorage:WaitForChild(globalName)
	if not remotes then
		remotes = Instance.new("Folder")
		remotes.Name = globalName
		remotes.Parent = ReplicatedStorage
	end
	for _, name in names do
		if RunService:IsClient() then
			local instance = remotes:WaitForChild(name)
			if instance:IsA(className) then
				map[name] = instance
			end
		else
			local instance = remotes:FindFirstChild(name)
			if instance then
				if not instance:IsA(className) then
					error("Found " .. (name .. " but it is not a remote."))
				end
				map[name] = instance
			else
				local remote = Instance.new(className)
				remote.Name = name
				remote.Parent = remotes
				map[name] = remote
			end
		end
	end
end
return {
	populateInstanceMap = populateInstanceMap,
}
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="40">
          <Properties>
            <string name="Name">@rbxts</string>
          </Properties>
          <Item class="Folder" referent="41">
            <Properties>
              <string name="Name">compiler-types</string>
            </Properties>
            <Item class="Folder" referent="42">
              <Properties>
                <string name="Name">types</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="43">
            <Properties>
              <string name="Name">maid</string>
            </Properties>
            <Item class="ModuleScript" referent="44">
              <Properties>
                <string name="Name">Maid</string>
                <string name="Source">---	Manages the cleaning of events and other things.
-- Useful for encapsulating state and make deconstructors easy
-- @classmod Maid
-- @see Signal

local Maid = {}
Maid.ClassName = "Maid"

--- Returns a new Maid object
-- @constructor Maid.new()
-- @treturn Maid
function Maid.new()
	local self = {}

	self._tasks = {}

	return setmetatable(self, Maid)
end

--- Returns Maid[key] if not part of Maid metatable
-- @return Maid[key] value
function Maid:__index(index)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--- Add a task to clean up
-- @usage
-- Maid[key] = (function)         Adds a task to perform
-- Maid[key] = (event connection) Manages an event connection
-- Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
-- Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
-- Maid[key] = nil                Removes a named task. If the task is an event, it is disconnected. If it is an object,
--                                it is destroyed.
function Maid:__newindex(index, newTask)
	if Maid[index] ~= nil then
		error(("'%s' is reserved"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]
	tasks[index] = newTask

	if oldTask then
		if type(oldTask) == "function" then
			oldTask()
		elseif typeof(oldTask) == "RBXScriptConnection" then
			oldTask:Disconnect()
		elseif oldTask.Destroy then
			oldTask:Destroy()
		end
	end
end

--- Same as indexing, but uses an incremented number as a key.
-- @param task An item to clean
-- @treturn number taskId
function Maid:GiveTask(task)
	assert(task, "Task cannot be false or nil")

	local taskId = #self._tasks+1
	self[taskId] = task

	if type(task) == "table" and (not task.Destroy) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

function Maid:GivePromise(promise)
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--- Cleans up all tasks.
-- @alias Destroy
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, task in pairs(tasks) do
		if typeof(task) == "RBXScriptConnection" then
			tasks[index] = nil
			task:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, task = next(tasks)
	while task ~= nil do
		tasks[index] = nil
		if type(task) == "function" then
			task()
		elseif typeof(task) == "RBXScriptConnection" then
			task:Disconnect()
		elseif task.Destroy then
			task:Destroy()
		end
		index, task = next(tasks)
	end
end

--- Alias for DoCleaning()
-- @function Destroy
Maid.Destroy = Maid.DoCleaning

return Maid</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="45">
            <Properties>
              <string name="Name">object-utils</string>
              <string name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Object = {}

function Object.keys(object)
	local result = table.create(#object)
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function Object.values(object)
	local result = table.create(#object)
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function Object.entries(object)
	local result = table.create(#object)
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function Object.assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

function Object.copy(object)
	local result = table.create(#object)
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopyHelper(object, encountered)
	local result = table.create(#object)
	encountered[object] = result

	for k, v in pairs(object) do
		if type(k) == "table" then
			k = encountered[k] or deepCopyHelper(k, encountered)
		end

		if type(v) == "table" then
			v = encountered[v] or deepCopyHelper(v, encountered)
		end

		result[k] = v
	end

	return result
end

function Object.deepCopy(object)
	return deepCopyHelper(object, {})
end

function Object.deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = Object.deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

function Object.toString(data)
	return HttpService:JSONEncode(data)
end

function Object.isEmpty(object)
	return next(object) == nil
end

function Object.fromEntries(entries)
	local entriesLen = #entries

	local result = table.create(entriesLen)
	if entries then
		for i = 1, entriesLen do
			local pair = entries[i]
			result[pair[1]] = pair[2]
		end
	end
	return result
end

return Object
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="46">
            <Properties>
              <string name="Name">services</string>
              <string name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="47">
            <Properties>
              <string name="Name">signal</string>
              <string name="Source"><![CDATA[local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		Bindable = Instance.new("BindableEvent");
	}, Signal)
end

function Signal:Connect(Callback)
	return self.Bindable.Event:Connect(function(GetArguments)
		Callback(GetArguments())
	end)
end

function Signal:Fire(...)
	local Arguments = { ... }
	local n = select("#", ...)

	self.Bindable:Fire(function()
		return table.unpack(Arguments, 1, n)
	end)
end

function Signal:Wait()
	return self.Bindable.Event:Wait()()
end

function Signal:Destroy()
	self.Bindable:Destroy()
end

return Signal
]]></string>
            </Properties>
          </Item>
          <Item class="Folder" referent="48">
            <Properties>
              <string name="Name">t</string>
            </Properties>
            <Item class="Folder" referent="49">
              <Properties>
                <string name="Name">lib</string>
              </Properties>
              <Item class="ModuleScript" referent="50">
                <Properties>
                  <string name="Name">ts</string>
                  <string name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

-- regular lua compatibility
local typeof = typeof or type

local function primitive(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

local t = {}

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = primitive("boolean")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = primitive("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = primitive("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = primitive("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = primitive("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = primitive("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = primitive("userdata")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	if value ~= value then
		return true
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = primitive("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = primitive("BrickColor")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = primitive("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = primitive("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = primitive("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = primitive("ColorSequenceKeypoint")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = primitive("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = primitive("Faces")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = primitive("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = primitive("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = primitive("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = primitive("NumberSequenceKeypoint")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = primitive("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = primitive("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = primitive("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = primitive("Ray")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = primitive("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = primitive("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = primitive("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = primitive("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = primitive("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = primitive("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = primitive("Vector2")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = primitive("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = primitive("Vector3int16")

-- roblox enum types

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = primitive("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = primitive("EnumItem")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = primitive("RBXScriptSignal")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = primitive("RBXScriptConnection")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The functon to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="51">
            <Properties>
              <string name="Name">types</string>
            </Properties>
            <Item class="Folder" referent="52">
              <Properties>
                <string name="Name">include</string>
              </Properties>
              <Item class="Folder" referent="53">
                <Properties>
                  <string name="Name">generated</string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="54">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="55">
      <Properties>
        <string name="Name">TS</string>
      </Properties>
      <Item class="Folder" referent="56">
        <Properties>
          <string name="Name">components</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="57">
        <Properties>
          <string name="Name">network</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _network = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network")
local GlobalEvents = _network.GlobalEvents
local GlobalFunctions = _network.GlobalFunctions
local Events = GlobalEvents.server
local Functions = GlobalFunctions.server
return {
	Events = Events,
	Functions = Functions,
}
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="58">
        <Properties>
          <string name="Name">runtime</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ "ServerScriptService", "TS", "controllers" })
Flamework._addPaths({ "ServerScriptService", "TS/common", "controllers" })
Flamework._addPaths({ "ServerScriptService", "TS", "components" })
Flamework._addPaths({ "ReplicatedStorage", "TS", "components" })
Flamework._addPaths({ "ServerScriptService", "TS/common", "components" })
Flamework._addPaths({ "ReplicatedStorage", "TS/common", "components" })
Flamework.ignite()
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="59">
        <Properties>
          <string name="Name">services</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="60">
      <Properties>
        <string name="Name">TS/common</string>
      </Properties>
    </Item>
  </Item>
  <Item class="ServerStorage" referent="61">
    <Properties>
      <string name="Name">ServerStorage</string>
    </Properties>
    <Item class="Folder" referent="62">
      <Properties>
        <string name="Name">assets</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="63">
      <Properties>
        <string name="Name">assets/shared</string>
      </Properties>
    </Item>
  </Item>
  <Item class="SoundService" referent="64">
    <Properties>
      <string name="Name">SoundService</string>
      <bool name="RespectFilteringEnabled">true</bool>
    </Properties>
  </Item>
  <Item class="StarterPlayer" referent="65">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="66">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="67">
        <Properties>
          <string name="Name">TS</string>
        </Properties>
        <Item class="Folder" referent="68">
          <Properties>
            <string name="Name">components</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="69">
          <Properties>
            <string name="Name">controllers</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="70">
          <Properties>
            <string name="Name">network</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _network = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "network")
local GlobalEvents = _network.GlobalEvents
local GlobalFunctions = _network.GlobalFunctions
local Events = GlobalEvents.client
local Functions = GlobalFunctions.client
return {
	Events = Events,
	Functions = Functions,
}
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="71">
          <Properties>
            <string name="Name">runtime</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ "StarterPlayer", "StarterPlayerScripts", "TS", "controllers" })
Flamework._addPaths({ "StarterPlayer", "StarterPlayerScripts", "TS/common", "controllers" })
Flamework._addPaths({ "StarterPlayer", "StarterPlayerScripts", "TS", "components" })
Flamework._addPaths({ "ReplicatedStorage", "TS", "components" })
Flamework._addPaths({ "StarterPlayer", "StarterPlayerScripts", "TS/common", "components" })
Flamework._addPaths({ "ReplicatedStorage", "TS/common", "components" })
Flamework.ignite()
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="72">
        <Properties>
          <string name="Name">TS/common</string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="73">
    <Properties>
      <string name="Name">Workspace</string>
      <bool name="FilteringEnabled">true</bool>
    </Properties>
  </Item>
</roblox>